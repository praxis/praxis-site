"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[8790],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=d(n),u=o,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||i;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4344:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=n(7462),o=(n(7294),n(3905));const i={title:"Building CRUD",sidebar_label:"Building CRUD"},r=void 0,s={unversionedId:"gettingStarted/buildingCRUD",id:"gettingStarted/buildingCRUD",title:"Building CRUD",description:"The way that people build CRUD operations often varies more than read-only operations like index and show. However, Praxis still brings in many best practices (and helper tools) that you can decide to follow. You can also decide not to follow these practices and implement your controller code however you see fit otherwise. That's one of the main goals of Praxis: at the core, it provides a solid Web API routing/parameter/controller Rack-based framework you can directly use (i.e., a la Sinatra), but you can easily opt-in to as many other extensions and best practices as you want (and you can even do it on a controller by controller basis, etc.)",source:"@site/docs/gettingStarted/buildingCRUD.md",sourceDirName:"gettingStarted",slug:"/gettingStarted/buildingCRUD",permalink:"/docs/gettingStarted/buildingCRUD",draft:!1,tags:[],version:"current",frontMatter:{title:"Building CRUD",sidebar_label:"Building CRUD"},sidebar:"mainSidebar",previous:{title:"Implementing Reads",permalink:"/docs/gettingStarted/implementingReads"},next:{title:"Introduction",permalink:"/docs/reference/intro"}},l={},d=[{value:"Update",id:"update",level:2},{value:"Designing Update",id:"designing-update",level:3},{value:"Implementing Update",id:"implementing-update",level:3},{value:"Create",id:"create",level:2},{value:"Designing Create",id:"designing-create",level:3},{value:"Implementing Create",id:"implementing-create",level:3},{value:"Delete",id:"delete",level:2},{value:"Designing Delete",id:"designing-delete",level:3},{value:"Implementing Delete",id:"implementing-delete",level:3}],p={toc:d},h="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The way that people build CRUD operations often varies more than read-only operations like ",(0,o.kt)("inlineCode",{parentName:"p"},"index")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"show"),". However, Praxis still brings in many best practices (and helper tools) that you can decide to follow. You can also decide not to follow these practices and implement your controller code however you see fit otherwise. That's one of the main goals of Praxis: at the core, it provides a solid Web API routing/parameter/controller Rack-based framework you can directly use (i.e., a la Sinatra), but you can easily opt-in to as many other extensions and best practices as you want (and you can even do it on a controller by controller basis, etc.)"),(0,o.kt)("p",null,"But anyway, we were talking about implementing the CRUD operations weren't we? Let's go through it one by one, first ",(0,o.kt)("inlineCode",{parentName:"p"},"update"),", then ",(0,o.kt)("inlineCode",{parentName:"p"},"create"),", and finally, ",(0,o.kt)("inlineCode",{parentName:"p"},"delete"),"."),(0,o.kt)("h2",{id:"update"},"Update"),(0,o.kt)("p",null,"Like always, we start by defining the API design of our new action."),(0,o.kt)("h3",{id:"designing-update"},"Designing Update"),(0,o.kt)("p",null,"For that, let's take a look at the scaffolded code from our generator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  action :update do\n    description 'Update one or more attributes of an existing Post'\n    routing { patch '/:id' }\n    params do\n      attribute :id, required: true\n    end\n    payload reference: MediaTypes::Post do\n      # List the attributes you accept from the one existing in the Post Mediatype\n      # and/or fully define any other ones you allow to change\n      # attribute :name\n    end\n    response :no_content\n    response :bad_request\n  end\n")),(0,o.kt)("p",null,"This defines that an update will be done through a ",(0,o.kt)("inlineCode",{parentName:"p"},"PATCH")," request to the member url of the posts collection (",(0,o.kt)("inlineCode",{parentName:"p"},"/posts/:id"),"), where ",(0,o.kt)("inlineCode",{parentName:"p"},":id")," is the given identifier of the post to update. As a response, the client can expect a ",(0,o.kt)("inlineCode",{parentName:"p"},"204 No Content")," when successful update or a ",(0,o.kt)("inlineCode",{parentName:"p"},"400 Bad Request")," if the request couldn't be completed (which will include information as to why it failed). Looks pretty reasonable so far."),(0,o.kt)("p",null,"Notice that query-string parameters are defined separately from body parameters. Query string parameters are defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"params")," block of the design, while request body structure is defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"payload")," block. In this case we will be defining the payload as a simple incoming hash-like structure, but bear in mind that it can be designed to accept arrays, and/or complex multipart bodies, etc."),(0,o.kt)("p",null,"The only thing that we need to modify from the scaffold code is the payload, as it contains the attributes we want to allow the client to update. You are obviously free to choose the shape and names of that structure. However, a Praxis best practice is to design incoming payload structures that mimic the rendered corresponding output MediaType (i.e., trying to keep symmetry between the shapes that go ",(0,o.kt)("em",{parentName:"p"},"into")," the API, and the shapes that get ",(0,o.kt)("em",{parentName:"p"},"out")," from it, as much as possible). To follow that tenet, to update a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),", we want to accept a payload that very much resembles the shape of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),". Therefore, it can have a ",(0,o.kt)("inlineCode",{parentName:"p"},"title"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"contents")," (and potentially an ",(0,o.kt)("inlineCode",{parentName:"p"},"author"),"), given that these are the only three existing attributes of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),". In this case, however, we won't allow sending an ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," attribute as that's something we might want to keep immutable from creation time. So in the most pure Praxis style, here's how the payload would be designed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  payload reference: MediaTypes::Post do\n    attribute :title\n    attribute :content\n  end\n")),(0,o.kt)("p",null,"Copy that to the ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," action of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," endpoint (",(0,o.kt)("inlineCode",{parentName:"p"},"design/v1/endpoints/posts.rb"),"). Now, let's take a look at a couple of things in this definition."),(0,o.kt)("p",null,"The first thing to notice is that we didn't define types for any of the attributes. What's that all about? Well, the answer lies in the ",(0,o.kt)("inlineCode",{parentName:"p"},"reference: MediaTypes::Post")," option passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"payload"),". When a payload is given a MediaType reference, any attributes will directly inherit all of their type and options from the attribute with the same name in the MediaType. In this case, ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," are both be defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," as that's the type they have in the reference ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," MediaType. Good, saved some keystrokes in there."),(0,o.kt)("p",null,"Notice that this is already a benefit from following the I/O symmetry paradigm, as it provides you with terser and more readable code, and it can help avoid silly copy and paste mistakes. We can always define any extra payload attribute we want (including its type and options), even if it does not exist in the reference MediaType. In fact, it is also possible to also redefine the type and options of an attribute, even if it exists in the reference MediaType (that's generally a bad practice, though, as it's not intuitive to the client)"),(0,o.kt)("p",null,"Another thing to notice from the definition is that none of the attributes are required. That is because this ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," action (through the ",(0,o.kt)("inlineCode",{parentName:"p"},"PATCH")," HTTP verb) only changes the attributes that are passed in, and leaves the rest untouched. If you wanted an update-type action that can change a member of the collection fully, we recommend the best practice of creating another action using a ",(0,o.kt)("inlineCode",{parentName:"p"},"PUT")," verb to the same member url, and call it something like ",(0,o.kt)("inlineCode",{parentName:"p"},"replace")," to clearly denote that it will replace ",(0,o.kt)("em",{parentName:"p"},"all")," values of the object, including resetting the ones that aren't passed in."),(0,o.kt)("p",null,"So all in all, we only needed to add a couple of attributes to the payload. Good times. Also, feel free to fire up the doc browser (",(0,o.kt)("inlineCode",{parentName:"p"},"bundle exec praxis docs browser"),") to see how our design turned out, in a more visually appealing way. Let's move to the implementation."),(0,o.kt)("h3",{id:"implementing-update"},"Implementing Update"),(0,o.kt)("p",null,"So let's now focus our efforts on building the implementation of what we have just designed. In particular we need to be able to update a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," based on the incoming payload we have defined. The first question is: how much should this controller code do? Let's turn to another important set of Praxis best practices."),(0,o.kt)("p",null,"An important suggestion from Praxis is to confine controller code to only deal with HTTP concepts and transformations (request and response params, payload, headers, HTTP codes and errors, and etc.), while specifically avoiding any business logic (application domain logic). There are many reasons for this but the most important ones have to do with separation of concerns, testability and business logic reuse."),(0,o.kt)("p",null,"So what Praxis proposes for the ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," action of our controller is to simply call an underlying business logic object to update a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),", commonly using the same action name (i.e., ",(0,o.kt)("inlineCode",{parentName:"p"},"update"),") and pass all of the necessary parameters to do it. Once that call to the underlying logic is done, then simply return the ",(0,o.kt)("inlineCode",{parentName:"p"},"204 No Content"),". Done. Short. Clean. Our controller only deals with HTTP protocol adaptation, with some massaging of the incoming/outgoing structures to and from the business logic objects."),(0,o.kt)("p",null,'Ok, so what are these business logic objects then? Well, Praxis calls them "Resources" and are nothing more than pure Ruby classes. Resources are the associated objects that sit in between the Controllers and the Data access, which contain the important business logic of your app. In other words: at the top level Controllers simply deal with HTTP and data structure concerns; at the lowest level Models deal with retrieving and saving data from or to the DB (or remote datasource). Resources are reusable components of business logic that sit in the middle and abstract the underlying related models (or other related resources).'),(0,o.kt)("p",null,"Alright, so how does that look in the controller code then? Let's take a look at the scaffolded code for the ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," action that our generator built for us:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  def update(id:)\n    # A good pattern is to retrieve the resource instance by id, and then\n    # call the same name method on it, by passing the incoming payload (or massaging it first)\n    resource = Resources::Post.get(id: id)\n    return Praxis::Responses::NotFound.new unless resource\n\n    resource.update(payload: request.payload)\n    Praxis::Responses::NoContent.new\n  end\n")),(0,o.kt)("p",null,"The first thing to notice is that the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," parameter we defined in our design step is passed in as a keyword argument to the function (it is a required param, as we have defined to be so, in our design). It is also accessible through ",(0,o.kt)("inlineCode",{parentName:"p"},"request.params.id")," but it is cleaner and more self-documenting to be a required function argument."),(0,o.kt)("p",null,"Another thing to notice is that the scaffolded code performs no validation whatsoever on the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," or the ",(0,o.kt)("inlineCode",{parentName:"p"},"payload")," elements. That is because a powerful part of building your API design with Praxis is that it will all be automatically validated and coerced before it can even reach your controller method. In other words, if our controller method is executed we can be 100% sure that the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," is an Integer, and any of the passed payload attributes are ",(0,o.kt)("inlineCode",{parentName:"p"},"Strings"),", as we have defined them. If there is any discrepancy with types and requirements of parameters, the framework would have detected it and already sent a validation error back to the client detailing exactly what didn't match the API specification."),(0,o.kt)("p",null,"The generated body of the function also follows the best practices we talked about. It first looks up the resource by ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," (using the ",(0,o.kt)("inlineCode",{parentName:"p"},".get")," method finders of a resource) and returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"404 NotFound")," if it does not exist. Then, it simply calls the instance method on the resource with the same name of the action, and gives it the necessary information to perform the job. In this case, the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),", and the incoming payload structure. If it all goes well, it will return a ",(0,o.kt)("inlineCode",{parentName:"p"},"204 No Content")," to indicate success. Some APIs like to return a ",(0,o.kt)("inlineCode",{parentName:"p"},"200 OK")," with the resulting body of the updated resource. While this is perfectly fine and valid, we suggest it is much cleaner (and computationally cheaper) to just signal success without returning any payload, and let the the client decide to read the latest copy of the object in a subsequent request if necessary. This way it can also clearly specify which of the fields (including nested resources) it wants to gather from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),". If we had to return the updated object in an update call, we'd either have to choose what fields to return, or somehow accept a ",(0,o.kt)("inlineCode",{parentName:"p"},"fields")," parameter to know what to render. These are all perfectly acceptable options, it's more a matter of preference."),(0,o.kt)("p",null,"Ok, so nothing for us to change here, that's cool. So let's now look at this ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," method of the resource, where the business logic lives:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  def update(payload:)\n    # Assuming the API field names directly map the the model attributes. Massage if appropriate.\n    record.update(**payload.to_h)\n    self\n  end\nend\n")),(0,o.kt)("p",null,"Well, it doesn't seem that we need to change anything here either! This scaffolded code simply updates the model attributes with the received values and returns the updated record wrapped in a resource instance. Done. Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," method in a resource corresponds to the underlying instance of the ORM model (i.e., an ActiveRecord or Sequel model). The simplicity of this method is due to the fact that the API attributes have the same name as the ORM model. If they were different, we would probably have to do some extra massaging before invoking the model's update method."),(0,o.kt)("p",null,"So with that, we have finished the implementation for updating Posts. Let's give it a go real quick, by first starting (or restarting) the web API (",(0,o.kt)("inlineCode",{parentName:"p"},"bundle exec rackup"),") and sending a PATCH request to change the title and content of ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),"=1:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"curl -XPATCH 'http://localhost:9292/posts/1' \\\n    -H 'X-Api-Version: 1' \\\n    -H 'Content-Type: application/json' \\\n    -d '{ \"title\": \"Changed Title\", \"content\": \"New Content\"}'\n")),(0,o.kt)("p",null,"There you go! You can now update posts. Check it out by reading the updated post with something like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"curl 'http://localhost:9292/posts/1?api_version=1' -G \\\n      --data-urlencode \"fields=id,title,content\"\n")),(0,o.kt)("p",null,"Ok, so this implementation for update took a bit of writing and explanation about best practices and options, but really, the scaffolding code did a very good job as we only had to change the payload definition of our ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," action! Not bad. Let's look at what happens when we implement ",(0,o.kt)("inlineCode",{parentName:"p"},"create"),"."),(0,o.kt)("h2",{id:"create"},"Create"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," action has many similarities with the previous ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," action. In fact, it could be almost identical. However, we are going to spice it up (for demonstration purposes) by accepting not only a ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," for a new post, but also a reference to an existing ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," as the author. Let's design the endpoint first."),(0,o.kt)("h3",{id:"designing-create"},"Designing Create"),(0,o.kt)("p",null,"The first thing to notice is the RESTful design choices that the scaffold generator did for us in the endpoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  action :create do\n    description 'Create a new Post'\n    routing { post '' }\n    payload reference: MediaTypes::Post do\n      # List the attributes you accept from the one existing in the Post Mediatype\n      # and/or fully define any other ones you allow at creation time\n      # attribute :name\n    end\n    response :created\n    response :bad_request\n  end\n")),(0,o.kt)("p",null,"This specifies that creating a post is done through a ",(0,o.kt)("inlineCode",{parentName:"p"},"POST")," verb to the collection url (",(0,o.kt)("inlineCode",{parentName:"p"},"/posts"),"), and successful creation will return a ",(0,o.kt)("inlineCode",{parentName:"p"},"204 Created")," response containing a Location header of the href for the created resource. Otherwise it will respond with a ",(0,o.kt)("inlineCode",{parentName:"p"},"400 Bad Request")," if the request couldn't be completed (with the included information as to why not)."),(0,o.kt)("p",null,"If we're good with this fairly standard RESTful practice, the only thing that this needs to be completed is to define what payload attributes we want to accept to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),"."),(0,o.kt)("p",null,"If we follow the INPUTS==OUTPUT best practices, we want to accept a payload that has a ",(0,o.kt)("inlineCode",{parentName:"p"},"title"),", a ",(0,o.kt)("inlineCode",{parentName:"p"},"contents")," and an ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," (with this attribute also matching a subset of the original ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," MediaType). So, in the more pure Praxis style, here's how the payload would be designed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  payload reference: MediaTypes::Post do\n    attribute :title\n    attribute :content\n    attribute :author do\n      attribute :id, required: true\n    end\n    requires.at_least(1).of :title, :content\n    requires.all :author\n  end\n")),(0,o.kt)("p",null,"Now, let's take a look at a couple of things from this definition."),(0,o.kt)("p",null,"The first one, again, is that we didn't define types for any of the attributes. There's no need since the attribute structure and names match the referenced ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," MediaType. Yay! Again a best practice that can reward you in terseness and avoid mistakes when you follow that paradigm. Note that any extra payload attribute that we might want to accept can still be fully defined with its type and options."),(0,o.kt)("p",null,"The second thing to notice is how we've defined the way to specify the author of the post. Often times you see a payload having an ",(0,o.kt)("inlineCode",{parentName:"p"},"author_id")," attribute, but following the symmetry paradigm we want to change that to have an ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," struct, with only an ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," inside. In the same fashion, we can trivially start accepting other author information like ",(0,o.kt)("inlineCode",{parentName:"p"},"email")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"uuid")," (even optionally within the ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," struct) to connect the ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," to it. It's all about the consistency and the principle of least surprise to your users of the API."),(0,o.kt)("p",null,"Finally (and more for demonstration purposes than anything else), we have decided that we can accept a post without a ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," or without a ",(0,o.kt)("inlineCode",{parentName:"p"},"content"),", but we need at least one of them (that's what the ",(0,o.kt)("inlineCode",{parentName:"p"},".at_least(1).of :title, :content")," stanza enforces). The ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," however is always required (along with its ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),")."),(0,o.kt)("p",null,"Let's turn to the implementation now."),(0,o.kt)("h3",{id:"implementing-create"},"Implementing Create"),(0,o.kt)("p",null,"This is the scaffolded code we find for ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," in the controller:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  # Creates a new Post\n  def create\n    # A good pattern is to call the same name method on the corresponding resource,\n    # passing the incoming payload, or massaging it first\n    created_resource = Resources::Post.create(request.payload)\n\n    # Respond with a created if it successfully finished\n    Praxis::Responses::Created.new(location: created_resource.href)\n  end\n")),(0,o.kt)("p",null,"Umm... well, that looks good enough, doesn't it? It is essentially the same pattern we saw in the ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," action, with the difference that we don't have a resource to lookup since\nit does not exist because we're gonna create it. That simply differs from ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," in that we don't look anything up (and we cannot return a ",(0,o.kt)("inlineCode",{parentName:"p"},"404 NotFound"),") and that we call a class method of the resource, instead of an instance method. Well, it seems we're done with our controller! Let's build the actual business logic, shall we?"),(0,o.kt)("p",null,"To do so, let's look at the scaffolded ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," resource in ",(0,o.kt)("inlineCode",{parentName:"p"},"app/v1/resources/post.rb"),". As you can see, it calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," method in the ",(0,o.kt)("inlineCode",{parentName:"p"},"model")," class (i.e., the ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," ActiveRecord class), passing the spatted parameters of our defined payload, and simply wraps the result with a new instance of the created resource:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  def self.create(payload)\n    # Assuming the API field names directly map the the model attributes. Massage if appropriate.\n    self.new(model.create(**payload.to_h))\n  end\n")),(0,o.kt)("p",null,"Now, this default scaffold assumes that the payload attributes of the API have the same name as the model attributes. With our inclusion of a linked ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," id in the payload, this is not 100% correct. So in this case, we do need to change the implementation a little bit to account for that. Not much, though, as we just need to change it to this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'  def self.create(payload)\n    author = Resources::User.get(id: payload.author.id)\n    raise "Author with id #{payload.author.id} not found" unless author\n    data = payload.to_h.merge(author: author.record)\n    self.new(model.create(**data))\n  end\n')),(0,o.kt)("p",null,"Let's look at what we've done. First we dig the ",(0,o.kt)("inlineCode",{parentName:"p"},"author.id")," from the payload and use the resource method ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," to look up the ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," resource in the DB by ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),". Note that we do not need to check if the ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," or the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," are null as that's all taken care for us by the framework. Also note that the defined payload is presented as a 'method-type-access' object, rather than a generic hash."),(0,o.kt)("p",null,"If we cannot find this user we need to signal something back to the client. In this trivial example we're just raising a string, but typically you'd have this code raise some well known error class and make the controller catch it and respond appropriately with the right HTTP response. For example, create a ",(0,o.kt)("inlineCode",{parentName:"p"},"ResourceNotFoundError")," class or similar, and use it to signal this business logic case (remember this code is not aware of any HTTP concerns, just application business logic). We'll leave this as an exercise to the reader ;)."),(0,o.kt)("p",null,"If we have found the user, we simply create a ruby hash from the payload and merge the ",(0,o.kt)("inlineCode",{parentName:"p"},":author")," attribute with the appropriate ActiveRecord model instance of the found User resource. ActiveRecord, in this case, knows how to properly fill in the foreign keys since the ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," model has an ",(0,o.kt)("inlineCode",{parentName:"p"},":author")," association defined pointing to the ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," model. We could have passed the ",(0,o.kt)("inlineCode",{parentName:"p"},":author_id")," field just as well."),(0,o.kt)("p",null,"And that's it. In this case we couldn't simply use the scaffolded code because we wanted to showcase accepting an ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," field on create, but it was fairly easy and short to adapt for it."),(0,o.kt)("p",null,"Now, let's restart our API server and create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),". To do that, we will send a POST request, with a body containing the ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," and an ",(0,o.kt)("inlineCode",{parentName:"p"},"author")," sub-hash containing an ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),". The following curl request creates a post titled ",(0,o.kt)("inlineCode",{parentName:"p"},"New Title"),", linked to author with ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),"=11:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"curl -XPOST 'http://localhost:9292/posts' \\\n    -D - \\\n    -H 'X-Api-Version: 1' \\\n    -H 'Content-Type: application/json' \\\n    -d '{ \"title\": \"New Title\", \"author\": { \"id\": 11}}'\n")),(0,o.kt)("p",null,'Note that we\'ve added the "-D -" flag to curl to ask it to print the response headers. This way we can confirm that we properly get a ',(0,o.kt)("inlineCode",{parentName:"p"},"Location")," header which tells us the URL (and therefore id) of the newly created post. Boom! it works!"),(0,o.kt)("p",null,"And finally, let's wrap up our CRUD tutorial by looking at the ",(0,o.kt)("inlineCode",{parentName:"p"},"delete")," action."),(0,o.kt)("h2",{id:"delete"},"Delete"),(0,o.kt)("p",null,"The delete action is definitely the easiest one, let's design it first."),(0,o.kt)("h3",{id:"designing-delete"},"Designing Delete"),(0,o.kt)("p",null,"From a design perspective, a delete is very similar to the ",(0,o.kt)("inlineCode",{parentName:"p"},"update"),", except that it does not need any payload information, it only needs the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," of the post to delete. Here's the scaffolded endpoint for delete:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  action :delete do\n    description 'Deletes a Post'\n    routing { delete '/:id' }\n    params do\n      attribute :id, required: true\n    end\n    response :no_content\n    response :not_found\n  end\n")),(0,o.kt)("p",null,"It all looks exactly how we want it. This defines that a delete is done through a ",(0,o.kt)("inlineCode",{parentName:"p"},"DELETE")," verb to the member url of the posts collection (",(0,o.kt)("inlineCode",{parentName:"p"},"/posts/:id"),"), where ",(0,o.kt)("inlineCode",{parentName:"p"},":id")," is the given identifier of the post. As a response, the client must expect a ",(0,o.kt)("inlineCode",{parentName:"p"},"204 No Content")," when successful update, or a ",(0,o.kt)("inlineCode",{parentName:"p"},"400 Bad Request")," when the request couldn't be completed (with included information as to why not)."),(0,o.kt)("p",null,"Ok then, nothing to be added...moving along to the implementation."),(0,o.kt)("h3",{id:"implementing-delete"},"Implementing Delete"),(0,o.kt)("p",null,"Looking at the scaffolded Controller implementation for delete also reveals a structure almost identical to ",(0,o.kt)("inlineCode",{parentName:"p"},"update"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  def delete(id:)\n    # A good pattern is to retrieve the resource instance by id, and then\n    # call the same name method on it\n    resource = Resources::Post.get(id: id)\n    return Praxis::Responses::NotFound.new unless resource\n\n    resource.delete\n    Praxis::Responses::NoContent.new\n  end\n")),(0,o.kt)("p",null,"In fact, it is exactly the same code but calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"delete")," method of the resource instead, which obviously does not need a payload. Good, nothing to do here either. How about the ",(0,o.kt)("inlineCode",{parentName:"p"},"delete")," method where the business logic lives?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"  def delete\n    record.destroy\n    self\n  end\n")),(0,o.kt)("p",null,"Well, nothing to be done here either as it simply calls the ",(0,o.kt)("inlineCode",{parentName:"p"},".destroys")," of the model. Nice job scaffolder!"),(0,o.kt)("p",null,"Wanna delete a post? Yeah, I thought so. Create one with the previous curl above, and use the resulting id to delete it (buy substituting the ",(0,o.kt)("inlineCode",{parentName:"p"},"YOUR_ID_HERE")," in the curl below for your id):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"curl -XDELETE 'http://localhost:9292/posts/YOUR_ID_HERE' \\\n    -H 'X-Api-Version: 1'\n")),(0,o.kt)("h1",{id:"summary"},"Summary"),(0,o.kt)("p",null,"So...just like that, we have built a full-on CRUD API for Posts, by literally just pasting a few lines of code (mostly just to define our own media type structures and payload attributes, as well as the ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," method of the resource due to our special-cased linked user). While the article is long, geared towards explaining how things work, the amount of code changes that were required to have a fully functioning API resource were very, very little. "),(0,o.kt)("p",null,"Hopefully you enjoyed it and have started to see that while this was just the tip of the iceberg, Praxis makes it easy and efficient to build powerful, consistent and fully documented APIs, all with extreme developer productivity. If you want to know more, we invite you to look at the reference guide, where you'll find things discussed at a much detailed level, and hopefully you can discover many more of the interesting features that Praxis comes with, which can hopefully make your life much better and enjoyable while you implement your APIs."))}c.isMDXComponent=!0}}]);