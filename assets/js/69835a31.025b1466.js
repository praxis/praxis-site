"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[5240],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,m=d["".concat(s,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8638:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={title:"Request Life Cycle"},r=void 0,l={unversionedId:"reference/implementation/request-life-cycle",id:"reference/implementation/request-life-cycle",title:"Request Life Cycle",description:"Praxis processes each incoming request by funneling them through a pipeline of stages. Stages are execution points during the servicing of a request, which could themselves contain a set of sub-stages. Each registered stage has a unique name and is connected to the other stages in a well-known order.",source:"@site/docs/reference/implementation/request-life-cycle.md",sourceDirName:"reference/implementation",slug:"/reference/implementation/request-life-cycle",permalink:"/docs/reference/implementation/request-life-cycle",draft:!1,tags:[],version:"current",frontMatter:{title:"Request Life Cycle"},sidebar:"mainSidebar",previous:{title:"Responses",permalink:"/docs/reference/implementation/responses"},next:{title:"Multipart Types",permalink:"/docs/reference/implementation/multipart"}},s={},p=[{value:"Request Loading Stage (<code>:load_request</code>)",id:"request-loading-stage-load_request",level:2},{value:"Validation Stage (<code>:validate</code>)",id:"validation-stage-validate",level:2},{value:"Action stage(<code>:action</code>)",id:"action-stageaction",level:2},{value:"Response Stage (<code>:response</code>)",id:"response-stage-response",level:2},{value:"Hooking Into the Request Life Cycle",id:"hooking-into-the-request-life-cycle",level:2},{value:"Shortcutting the request processing",id:"shortcutting-the-request-processing",level:3}],c={toc:p},d="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Praxis processes each incoming request by funneling them through a pipeline of stages. Stages are execution points during the servicing of a request, which could themselves contain a set of sub-stages. Each registered stage has a unique name and is connected to the other stages in a well-known order."),(0,i.kt)("p",null,"Praxis allows applications to 'hook into' any of those existing stages through ",(0,i.kt)("inlineCode",{parentName:"p"},"before"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"after")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"around")," callbacks and provides facilities to create or alter the pipeline. Any stage or its hooks are able to abort the pipeline processing early, and shortcut directly to sending a response to the client. A callback can indicate such shortcut by simply returning a ",(0,i.kt)("inlineCode",{parentName:"p"},"Praxis::Request")," object. Note that when a callback does that, any other further callbacks are not going to be invoked."),(0,i.kt)("p",null,"Note: while stages in the request lifecycle might behave similarly to bootstrap stages (as described ",(0,i.kt)("a",{parentName:"p",href:"../internals/bootstrapping"},"here"),"), they perform a different role. Request life cycle stages define the processing path for every incoming request, while bootstrapping stages define the execution order when the application first boots."),(0,i.kt)("p",null,"Praxis comes out of the box with the following pipeline of stages for any incoming request:"),(0,i.kt)("p",null,"![Request Life Cycle Diagram]","({{ site.baseurl }}/public/images/praxis_request_life_cycle_diagram.png)"),(0,i.kt)("p",null,"The first of these stages in the pipeline will start after the routing has been processed for the incoming request and the appropriate controller and action has\nbeen identified. This means that currently, there is no way to affect the request routing dynamically."),(0,i.kt)("h2",{id:"request-loading-stage-load_request"},"Request Loading Stage (",(0,i.kt)("inlineCode",{parentName:"h2"},":load_request"),")"),(0,i.kt)("p",null,"The request loading stage is used to retrieve all the necessary information from the incoming HTTP request so that it is ready for processing."),(0,i.kt)("p",null,"This involves:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"parsing the parameters from the URI captures"),(0,i.kt)("li",{parentName:"ul"},"retrieving any parameters from query string"),(0,i.kt)("li",{parentName:"ul"},"retrieving the paylod contents"),(0,i.kt)("li",{parentName:"ul"},"retrieving the incoming headers")),(0,i.kt)("p",null,"All of these are done, without performing any parsing or type coercion: simply gathering the low-level arguments in one place."),(0,i.kt)("p",null,"Note: Strictly speaking retrieving the query string params involves some form-encoding parsing, but it still does not involve any type coercion."),(0,i.kt)("h2",{id:"validation-stage-validate"},"Validation Stage (",(0,i.kt)("inlineCode",{parentName:"h2"},":validate"),")"),(0,i.kt)("p",null,"During the Validate stage, Praxis will gather the raw data retrieved from the loading stage and will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"load them into (read: coerce if necessary) into the proper structures as defined in your endpoint definitions for the action that this request is serving."),(0,i.kt)("li",{parentName:"ul"},"validate these created objects based on the requirements set forth by the endpoint definitions.")),(0,i.kt)("p",null,"These two tasks are done for data corresponding to headers, parameters and payload. In practice, this will result in creating the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"headers"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"params")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," objects accessible through the ",(0,i.kt)("inlineCode",{parentName:"p"},"request")," object in the controller. Any errors while loading the data into the right types, or validating\ntheir integrity will cause Praxis to abort the pipeline (by shortcutting to the  ",(0,i.kt)("inlineCode",{parentName:"p"},":response")," stage) and immediately return an error to the end user indicating the exact\nproblem (or problems) that were encountered about the incoming data."),(0,i.kt)("p",null,"The Validation stage is further composed of two sub-stages."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},":headers_and_params")," : First, this stage will load the headers and the parameters. If all loaded fine they will both be validated in the same order."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},":payload")," : Then this stage will load the incoming payload and then validate its integrity after that.")),(0,i.kt)("p",null,"Splitting it is these sub-stages it allows enough flexibility to hook into the desired step."),(0,i.kt)("h2",{id:"action-stageaction"},"Action stage(",(0,i.kt)("inlineCode",{parentName:"h2"},":action"),")"),(0,i.kt)("p",null,"Once the incoming request has been loaded and validated, the next step is to deliver it to the controller action that will service it. At this point Praxis has created a ",(0,i.kt)("inlineCode",{parentName:"p"},"Praxis::Request")," instance, and made it available to the controller through the ",(0,i.kt)("inlineCode",{parentName:"p"},"request")," method. This object will have the ",(0,i.kt)("inlineCode",{parentName:"p"},"headers"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"params")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," methods, which will return the appropriately loaded and validated objects, as defined in your endpoints. The same ",(0,i.kt)("inlineCode",{parentName:"p"},"params")," attributes will also be splatted into keyword arguments of your controller action."),(0,i.kt)("p",null,"The request enters the Action stage at the point when the controller action is invoked. This is the stage where the application will do its logic. Note that your controller only gets invoked if the validation stage succeeds. Therefore, your action should never validate any of the ",(0,i.kt)("inlineCode",{parentName:"p"},"params"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"headers")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," in its code as they are guaranteed to match all of the requirements of your definition."),(0,i.kt)("h2",{id:"response-stage-response"},"Response Stage (",(0,i.kt)("inlineCode",{parentName:"h2"},":response"),")"),(0,i.kt)("p",null,"The Response stage is going to ",(0,i.kt)("em",{parentName:"p"},"always")," be invoked, even when any of the previous pipeline stages have decided to shortcut the cycle. This is done to give the application\na chance to catch and possibly modify the logic involved in returning the response to the user, even when it is an error response. In the normal, non-error case however, the Response stage is entered when the control returns from the controller action stage."),(0,i.kt)("p",null,"The responsibility of this stage is to inspect the returned value (usually a response instance) and perform the necessary steps to unpack it and send it back to the client."),(0,i.kt)("p",null,"Note that if any of the around, before or after filters in any other stage return a ",(0,i.kt)("inlineCode",{parentName:"p"},"Response")," objecy, the request pipeline is immediately shortcut to this ",(0,i.kt)("inlineCode",{parentName:"p"},":response")," stage. Therefore, you should never assume that your filters will all be invoked by the time the ",(0,i.kt)("inlineCode",{parentName:"p"},":response")," stage code starts. For example, if there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"before :action"),"\nfilter that sets the current user into the request object, do not assume that this user will be correctly set when the response stage executes, as previous ",(0,i.kt)("inlineCode",{parentName:"p"},"before :action")," filter might have shortcut the cycle first."),(0,i.kt)("h2",{id:"hooking-into-the-request-life-cycle"},"Hooking Into the Request Life Cycle"),(0,i.kt)("p",null,"There are three types of hooks you can use to run a block of code during the\nlife cycle of a request. You can register a callback to be run either ",(0,i.kt)("inlineCode",{parentName:"p"},"before"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"after")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"around")," any of the available stages."),(0,i.kt)("p",null,"Installing callbacks is done directly from your controller. Just use the class\nDSL methods ",(0,i.kt)("inlineCode",{parentName:"p"},"before"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"after")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"around")," that comes with the Praxis::Callback\nconcerns(already included by the Praxis::Controller module). Each of these methods take\nthe name of the stage to hook into, an optional list of options, and a callback block."),(0,i.kt)("p",null,"The name of the stage can be any of the ones described above: ",(0,i.kt)("inlineCode",{parentName:"p"},":load_request"),", ",(0,i.kt)("inlineCode",{parentName:"p"},":validate")," (including ",(0,i.kt)("inlineCode",{parentName:"p"},":validate, :headers_and_params")," or ",(0,i.kt)("inlineCode",{parentName:"p"},":validate, :payload")," to tap into a sub-stage only ), ",(0,i.kt)("inlineCode",{parentName:"p"},":action")," or ",(0,i.kt)("inlineCode",{parentName:"p"},":response"),"."),(0,i.kt)("p",null,"The only option supported at the time of this writing is ",(0,i.kt)("inlineCode",{parentName:"p"},":actions"),", which\nallows the caller to restrict the callback to be applied only to a set of named actions.\nPassing no ",(0,i.kt)("inlineCode",{parentName:"p"},"actions")," option is logically equivalent to passing every possible action in\nyour controller. More options for callbacks might be introduced in the future."),(0,i.kt)("p",null,"To install your hook for substages, pass a second argument after the stage name (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"after :validate, :payload ...")," for tapping into the ",(0,i.kt)("inlineCode",{parentName:"p"},":payload")," substage of ",(0,i.kt)("inlineCode",{parentName:"p"},":validation"),"). If you completely omit the stage name, Praxis will default to the ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," stage because that's the most common use case."),(0,i.kt)("p",null,"Here are some examples of how to register callbacks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'  before :action, actions: [:show] do\n    puts "Will print before invoking the controller method, for show action only"\n  end\n\n  before actions: [:show] do\n    puts "Omiting the :action parameter!"\n    puts "This is equivalent to the callback above"\n  end\n\n  after :validate, :payload do |controller|\n    puts "Will print after validating the payload for any action"\n  end\n\n  after :validate, :payload, actions: [:create] do |controller|\n    puts "Will print after validating the payload for create only"\n  end\n\n  after :validate do\n    put "Will print after the headers and payload substages\' after callbacks"\n  end\n  \n  around :action do |controller, callee|\n    puts "Before the action is called"\n    callee.call\n    puts "After the action is called"\n  end\nend\n')),(0,i.kt)("p",null,"Technically speaking there is not much difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"after :validate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"before :action")," since they are subsequent stages. Semantically, however, they are different as all the ",(0,i.kt)("inlineCode",{parentName:"p"},"after :validate")," callbacks will be executed before any of the ",(0,i.kt)("inlineCode",{parentName:"p"},"before :action")," ones. So you should really register the callback based on what stage you depend on, and not on neighboring stages. Otherwise, your code might stop functioning when the pipeline order is changed."),(0,i.kt)("p",null,"There is, however, an important difference beween an ",(0,i.kt)("inlineCode",{parentName:"p"},"after :action")," callback, and a ",(0,i.kt)("inlineCode",{parentName:"p"},"before :response")," one. That is because the ",(0,i.kt)("inlineCode",{parentName:"p"},":response")," stage is always invoked regardless of errors in the previous stages. Therefore ",(0,i.kt)("inlineCode",{parentName:"p"},"after :action")," will be always skipped on previous stage shortcuts, while ",(0,i.kt)("inlineCode",{parentName:"p"},"before :response")," will always be invoked regardless of shortcuts (assuming that no other ",(0,i.kt)("inlineCode",{parentName:"p"},"before :response")," callbacks fail before)."),(0,i.kt)("p",null,"There is currently no mechanism to order the callbacks for a given stage. They will be executed\nin the order that they were registered. Also, there is currently no way to install callbacks around the complete request lifecycle, for example, to install an ",(0,i.kt)("inlineCode",{parentName:"p"},"around")," callback wrapping all of the\nindividual request stages. Both of these mechanisms can be added if the need arises.\nTo achieve something similar to a request ",(0,i.kt)("inlineCode",{parentName:"p"},"around")," filter, use the ",(0,i.kt)("a",{parentName:"p",href:"../implementation/application"},"builtin middleware registration")," that the Application provides"),(0,i.kt)("h3",{id:"shortcutting-the-request-processing"},"Shortcutting the request processing"),(0,i.kt)("p",null,"Any of the registered callback blocks (or the core stage execution code itself) can return a\n",(0,i.kt)("inlineCode",{parentName:"p"},"Praxis::Response")," instance to signal the interruption of the request lifecycle processing. Anything else that the block returns (i.e., nil or any other value) will be ignored and assumed that it signals that the processing should continue."),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"before")," callback returns a response, the system will immediately stop processing any further\ncallbacks of any kind, and shortcut the execution to the ",(0,i.kt)("inlineCode",{parentName:"p"},":response")," stage. This means that (with\nthe exception of the ",(0,i.kt)("inlineCode",{parentName:"p"},":request")," stage):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"no other ",(0,i.kt)("inlineCode",{parentName:"li"},"before")," callbacks in the chain will be executed"),(0,i.kt)("li",{parentName:"ul"},"none of the ",(0,i.kt)("inlineCode",{parentName:"li"},"around")," filters will be executed"),(0,i.kt)("li",{parentName:"ul"},"the action won't be invoked "),(0,i.kt)("li",{parentName:"ul"},"none of the ",(0,i.kt)("inlineCode",{parentName:"li"},"after")," callbacks will be run either")),(0,i.kt)("p",null,"If an ",(0,i.kt)("inlineCode",{parentName:"p"},"after")," callback returns a response, no further ",(0,i.kt)("inlineCode",{parentName:"p"},"after")," callbacks will be executed either.\nAlso note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"around")," callbacks are always started in after the ",(0,i.kt)("inlineCode",{parentName:"p"},"before")," ones, since they wrap the processing of the controller ",(0,i.kt)("inlineCode",{parentName:"p"},"action"),"."))}h.isMDXComponent=!0}}]);