"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[5444],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),p=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return i.createElement(l.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(t),h=a,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||o;return t?i.createElement(m,r(r({ref:n},d),{},{components:t})):i.createElement(m,r({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:a,r[1]=s;for(var p=2;p<o;p++)r[p]=t[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},837:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=t(7462),a=(t(7294),t(3905));const o={title:"Endpoints"},r=void 0,s={unversionedId:"reference/design/endpoints",id:"reference/design/endpoints",title:"Endpoints",description:"With Praxis, you can define all of the API endpoints that your API provides. An endpoint is commonly a set of API actions that are related to a given resource type or related set of actions. i.e., the Users endpoint might define all the actions to list, create and update users.",source:"@site/docs/reference/design/endpoints.md",sourceDirName:"reference/design",slug:"/reference/design/endpoints",permalink:"/docs/reference/design/endpoints",draft:!1,tags:[],version:"current",frontMatter:{title:"Endpoints"},sidebar:"mainSidebar",previous:{title:"Media Types",permalink:"/docs/reference/design/media-types"},next:{title:"Actions",permalink:"/docs/reference/design/actions"}},l={},p=[{value:"Description",id:"description",level:2},{value:"Routing Prefix",id:"routing-prefix",level:2},{value:"Media Type",id:"media-type",level:2},{value:"Version",id:"version",level:2},{value:"Parent Resource",id:"parent-resource",level:2},{value:"Action Defaults",id:"action-defaults",level:2},{value:"Canonical Paths",id:"canonical-paths",level:2},{value:"nodoc!",id:"nodoc",level:2}],d={toc:p},c="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"With Praxis, you can define all of the API endpoints that your API provides. An endpoint is commonly a set of API actions that are related to a given resource type or related set of actions. i.e., the Users endpoint might define all the actions to list, create and update users."),(0,a.kt)("p",null,"Defining an endpoint is done by creating a class that derives from ",(0,a.kt)("inlineCode",{parentName:"p"},"Praxis::EndpointDefinition"),". Using this class you will be able to define all of the aspects of your endpoint including versioning, description, all actions, with their parameters, routing, responses, authentication and etc."),(0,a.kt)("p",null,"Here's a simple example of a ",(0,a.kt)("inlineCode",{parentName:"p"},"Blogs")," endpoint definition which provides actions related to the ",(0,a.kt)("inlineCode",{parentName:"p"},"MediaTypes::Blog")," media type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Blogs\n  include Praxis::EndpointDefinition\n\n  media_type MediaTypes::Blog\n  version '1.0'\n\n  description <<-EOS\n    Blogs is the Resource where you write your thoughts.\n\n    And there's much more I could say about this resource...\n  EOS\n\n  action :index do\n    routing { get '' }\n    description 'Fetch all blog entries'\n    response :ok, Praxis::Collection.of(MediaTypes::Blog)\n  end\n\n  action :show do\n    routing { get '/:id' }\n    description 'Fetch a single blog by id'\n    params do\n      attribute :id\n    end\n    response :ok\n  end\n\n  action :create do\n    description 'Create a new Blog'\n    routing { post '' }\n    payload reference: MediaTypes::Blog do\n        attribute :title\n        attribute :description\n    end\n    response :created\n    response :bad_request\n  end\nend\n")),(0,a.kt)("p",null,'At a glance, we have defined that this endpoint will respond only to Api version "1.0", it has a description, uses a routing prefix of "/blogs", and exposes simple ',(0,a.kt)("inlineCode",{parentName:"p"},":index"),", ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," and ",(0,a.kt)("inlineCode",{parentName:"p"},":create")," actions.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},":index")," action returns a collection of blogs and does not take any parameters. The ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," action takes an id parameter and returns a single Blog media-type. While ",(0,a.kt)("inlineCode",{parentName:"p"},":index")," and ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," respond to HTTP GET verbs, the ",(0,a.kt)("inlineCode",{parentName:"p"},":create")," action responds is accessible through a ",(0,a.kt)("inlineCode",{parentName:"p"},"POST /blogs"),", and can take a payload that contains a title and a description field. Successful requests will return a 201 created HTTP code, while sending a bad parameters will cause a 400 Bad Request response with the body containing the cause."),(0,a.kt)("p",null,"Let's dig into the different configuration pieces available when defining endpoints"),(0,a.kt)("h2",{id:"description"},"Description"),(0,a.kt)("p",null,"You can specify a description for the endpoint definition using the ",(0,a.kt)("inlineCode",{parentName:"p"},"description"),"\nmethod. This description string is just for human consumption and is simply inserted directly into the generated API documentation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Blogs\n  include Praxis::EndpointDefinition\n  description <<-EOS\n    Blogs is the Resource where you write your thoughts.\n\n    And there's much more I could say about this resource...\n  EOS\nend\n")),(0,a.kt)("h2",{id:"routing-prefix"},"Routing Prefix"),(0,a.kt)("p",null,"Each endpoint definition has a routing prefix (partial path) which Praxis will\nautomatically prepend to all of the routes found in all of the actions of its resource. By default, this\nprefix is the class name of the endpoint definition converted to snake-case.\nFor our ",(0,a.kt)("inlineCode",{parentName:"p"},"Blogs")," endpoint definition above, the default routing prefix is\n",(0,a.kt)("inlineCode",{parentName:"p"},"blogs"),". To override the default routing prefix, simply provide a value using the ",(0,a.kt)("inlineCode",{parentName:"p"},"prefix")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Blogs\n  include Praxis::EndpointDefinition\n\n  prefix '/my-blogs'\nend\n")),(0,a.kt)("h2",{id:"media-type"},"Media Type"),(0,a.kt)("p",null,'Since endpoints usually group a collection of actions that are related to a type, you can set the "default" media type of a endpoint definition. This way, if the majority of actions return the same media-type, you don\'t need to repeat it as much.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Blogs\n  include Praxis::EndpointDefinition\n\n  media_type BlogMediaType\nend\n")),(0,a.kt)("p",null,"A MediaType in Praxis is often more than just an internet media-type string.\nIt commonly refers to the structure or schema with which a given resource type\nwill be displayed. This structure is also often associated with an internet media-type string (i.e.\nthe string is the ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," for the structure schema)."),(0,a.kt)("p",null,"The value you pass to the media_type method must be a:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Praxis::MediaType"),"-derived class that defines the attributes\navailable for representing an API resource."),(0,a.kt)("li",{parentName:"ul"},"string representing an internet media type identifier (i.e.\n'application/json').")),(0,a.kt)("p",null,"For more information on Praxis media types, please see ",(0,a.kt)("a",{parentName:"p",href:"media-types"},"MediaTypes"),"."),(0,a.kt)("h2",{id:"version"},"Version"),(0,a.kt)("p",null,"You can apply an API version to a endpoint definition by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"version"),"\nmethod:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Blogs\n  include Praxis::EndpointDefinition\n\n  version '1.0'\nend\n")),(0,a.kt)("p",null,"Setting the version of a endpoint definition allows you to have version control\nover the resources available through the API."),(0,a.kt)("p",null,"You can use any string as a version. By using the version method, you're\ntelling Praxis to only dispatch actions for this resource when the incoming request\ncarries the correct version value."),(0,a.kt)("p",null,"An incoming request can specify a version in three different ways:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"By providing an ",(0,a.kt)("inlineCode",{parentName:"li"},"X-Api-Version")," header containing the defined version string. Example: ",(0,a.kt)("inlineCode",{parentName:"li"},"X-Api-Version: 1.0")),(0,a.kt)("li",{parentName:"ul"},"By providing an ",(0,a.kt)("inlineCode",{parentName:"li"},":api_version")," parameter in the query containing the defined version string. Example: ",(0,a.kt)("inlineCode",{parentName:"li"},"/blogs?api_version")),(0,a.kt)("li",{parentName:"ul"},"By using an appropriate URL prefix. Example: ",(0,a.kt)("inlineCode",{parentName:"li"},"/v1.0/blogs"))),(0,a.kt)("p",null,"You can read more about how to configure the allowable ways to version the API in the ",(0,a.kt)("a",{parentName:"p",href:"api-definition"},"API definition")," section"),(0,a.kt)("h2",{id:"parent-resource"},"Parent Resource"),(0,a.kt)("p",null,"Often times, we want to expose certain API resources embedded into others. For this reason, Praxis provides an easy way to define the parent of a resource by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"parent")," directive. This will configure the resource to use its parent's ",(0,a.kt)("inlineCode",{parentName:"p"},"canonical_path")," as the base for all of its actions (in addition to any ",(0,a.kt)("inlineCode",{parentName:"p"},"prefix")," you may define on this resource). By default, a canonical path is the ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," action of an endpoint (but can be changed using the ",(0,a.kt)("inlineCode",{parentName:"p"},"canonical_path :<action_name>")," method in the definition)"),(0,a.kt)("p",null,"Additionally, any parameters in the parent's route will also be applied as defaults in the child. The last route parameter is assumed to be an 'id'-type parameter, and is prefixed with the parent's snake-cased singular name. I.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," from a ",(0,a.kt)("inlineCode",{parentName:"p"},"Blog")," parent will be renamed to ",(0,a.kt)("inlineCode",{parentName:"p"},"blog_id"),". Any other parameters are copied unchanged."),(0,a.kt)("p",null,'This behavior can be overridden by providing a mapping hash of the form { "parent_name" => "child_name" } to the ',(0,a.kt)("inlineCode",{parentName:"p"},"parent")," directive."),(0,a.kt)("p",null,"For example, to define a ",(0,a.kt)("inlineCode",{parentName:"p"},"Posts")," subresource of the above ",(0,a.kt)("inlineCode",{parentName:"p"},"Blogs")," resource:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Posts\n  include Praxis::EndpointDefinition\n\n  parent Blogs\n\n  action :show do\n    routing { get '/:id' }\n  end\n\nend\n")),(0,a.kt)("p",null,"This would result in the ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," action responding to the following path ",(0,a.kt)("inlineCode",{parentName:"p"},"/blogs/:blog_id/posts/:id"),", due to the canonical path of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Blogs")," resource being ",(0,a.kt)("inlineCode",{parentName:"p"},"/blogs/:id"),"."),(0,a.kt)("p",null,"To achieve a custom parent parameter we can change ",(0,a.kt)("inlineCode",{parentName:"p"},"parent Blogs")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"parent Blogs, :id => :parent_id"),". This results in the following path: ",(0,a.kt)("inlineCode",{parentName:"p"},"/blogs/:parent_id/posts/:id"),"."),(0,a.kt)("h2",{id:"action-defaults"},"Action Defaults"),(0,a.kt)("p",null,"There are often situations where many actions within a endpoint will\nrequire a common subset of definitions. For example, a common set of URL parameters,\na common set of headers, traits or even a common set of allowed responses."),(0,a.kt)("p",null,"Praxis allows you to easily define and share common pieces of code across all actions\nby placing their definitions inside an ",(0,a.kt)("inlineCode",{parentName:"p"},"action_defaults")," block at the endpoint definition level.\nHere is an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Blogs\n  include Praxis::EndpointDefinition\n\n  action_defaults do\n    params do\n      attribute :dry_run, Attributor::Boolean, default: false\n    end\n    response :bad_request\n  end\n\n  action :index do\n    routing { get '' }\n  end\n\n  action :show do\n    routing { get '/:id' }\n    params do\n      attribute :id, String\n    end\n  end\n\nend\n")),(0,a.kt)("p",null,"The example above will cause the ",(0,a.kt)("inlineCode",{parentName:"p"},":dry_run")," parameter to be propagated and\ndefined in all available actions of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Blogs")," endpoint definition (i.e., both\n",(0,a.kt)("inlineCode",{parentName:"p"},":index")," and ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," actions will have such a parameter)."),(0,a.kt)("p",null,"With ",(0,a.kt)("inlineCode",{parentName:"p"},"action_defaults")," you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"params"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"payload"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"headers"),", and\n",(0,a.kt)("inlineCode",{parentName:"p"},"response")," stanzas. If any of those stanzas are defined within an action itself Praxis will\nappropriately merge them. Therefore, in this example, the ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," action will\nend up with both the ",(0,a.kt)("inlineCode",{parentName:"p"},":dry_run")," and ",(0,a.kt)("inlineCode",{parentName:"p"},":id")," parameters."),(0,a.kt)("p",null,"In case of conflict while merging, Praxis will always give overriding preference\nto definitions found within the action block itself."),(0,a.kt)("h2",{id:"canonical-paths"},"Canonical Paths"),(0,a.kt)("p",null,"By default the canonical path for an endpoint will point to the routing path of the ",(0,a.kt)("inlineCode",{parentName:"p"},":show")," action. However, you can specify which action should be used for the resource's canonical href with the ",(0,a.kt)("inlineCode",{parentName:"p"},"canonical_path")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Blogs\n  include Praxis::EndpointDefinition\n\n  canonical_path :show\nend\n")),(0,a.kt)("p",null,"Having the appropriate ",(0,a.kt)("inlineCode",{parentName:"p"},"canonical_path")," allows you to both generate and parse hrefs for a given resource by using:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"EndpointDefinition.to_href(<named arguments hash>)")," to generate an href for the resource."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"EndpointDefinition.parse_href(<href String>)")," to get a type-coerced hash of the parameters for the canonical action from the given string.")),(0,a.kt)("p",null,"Given a controller (class or instance), you can use use those helpers by first calling its ",(0,a.kt)("inlineCode",{parentName:"p"},"definition")," method to retrieve the ",(0,a.kt)("inlineCode",{parentName:"p"},"EndpointDefinition")," it implements, and then using either ",(0,a.kt)("inlineCode",{parentName:"p"},"to_href")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"parse_href")," as described above. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"class Posts\n  include Praxis::Controller\n\n  implements Endpoints::Posts\n\n  def show(id:)\n    Posts.definition.to_href(id: 1)         # => /posts/1\n    Posts.definition.parse_href('/posts/1') # => { id: 1 }\n    # ...\n  end\nend\n")),(0,a.kt)("h2",{id:"nodoc"},"nodoc!"),(0,a.kt)("p",null,"TODO:  DEPRECATE IT??\nYou can mark a resource for exclusion from generated documentation by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"nodoc!")," method:"),(0,a.kt)("p",null,"{% highlight ruby %}\nclass Blogs\ninclude Praxis::EndpointDefinition"),(0,a.kt)("p",null,"  nodoc!\nend\n{% endhighlight %}"),(0,a.kt)("p",null,"Additionally, the resource's actions and media type (if specified) will not be used when determining which media types should be documented."),(0,a.kt)("p",null,"The next big thing to expore is how we can define each of the specific actions for the endpoint."))}u.isMDXComponent=!0}}]);