(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{101:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return d}));var o=n(3),a=n(7),r=(n(0),n(133)),i={title:"Setting Up Our Database",sidebar_label:"Setting Up Our Database"},s={unversionedId:"gettingStarted/settingUpOurDB",id:"gettingStarted/settingUpOurDB",isDocsHomePage:!1,title:"Setting Up Our Database",description:"So obviously, to have our API provide data, we need to have a DB with the proper posts and comments tables, and ideally populated with some interesting data. This part has nothing to do with Praxis, but it still needs to be done! Note that if you're building a Praxis API to serve already existing DB data, the only thing you need to do is to configure your models. Or even better, if you're building a Praxis API to serve already existing models within a Rails app, none of this needs to be done, as it's already in place. You can read more about how to build this within an existing Rails app in the documentation for the  MiddlewareApp module.",source:"@site/docs/gettingStarted/settingUpOurDB.md",slug:"/gettingStarted/settingUpOurDB",permalink:"/docs/gettingStarted/settingUpOurDB",version:"current",sidebar_label:"Setting Up Our Database",sidebar:"mainSidebar",previous:{title:"Designing our API resources",permalink:"/docs/gettingStarted/designingApiResources"},next:{title:"Implementing Reads",permalink:"/docs/gettingStarted/implementingReads"}},l=[],c={toc:l};function d(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"So obviously, to have our API provide data, we need to have a DB with the proper posts and comments tables, and ideally populated with some interesting data. This part has nothing to do with Praxis, but it still needs to be done! Note that if you're building a Praxis API to serve already existing DB data, the only thing you need to do is to configure your models. Or even better, if you're building a Praxis API to serve already existing models within a Rails app, none of this needs to be done, as it's already in place. You can read more about how to build this within an existing Rails app in the documentation for the  ",Object(r.b)("inlineCode",{parentName:"p"},"MiddlewareApp")," module."),Object(r.b)("p",null,"But we digress, let's first create the tables we want with a migration. Here's a quick and dirty thing you can copy paste to generate that. Note that we're simply adding a ",Object(r.b)("inlineCode",{parentName:"p"},"title")," and ",Object(r.b)("inlineCode",{parentName:"p"},"content"),' field to the posts, as well as a "foreign key" to the users table for the ',Object(r.b)("inlineCode",{parentName:"p"},"author")," of the post. Remember that the initial example app we built upon already has a very basic users table. For the comments, we're only adding a ",Object(r.b)("inlineCode",{parentName:"p"},"content")," field, and a couple of keys to point back to the id of the associated ",Object(r.b)("inlineCode",{parentName:"p"},"post"),", and the ",Object(r.b)("inlineCode",{parentName:"p"},"user")," who made the comment. All very straightforward. Feel free to copy and paste the following snippet onto your shell:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-shell",metastring:'title="Create an ActiveRecord migration for posts and comments"',title:'"Create',an:!0,ActiveRecord:!0,migration:!0,for:!0,posts:!0,and:!0,'comments"':!0}),"cat <<EOT > db/migrate/20210101010111_create_posts_and_comments_table.rb\nclass CreatePostsAndCommentsTable < ActiveRecord::Migration[5.2]\n  def change\n    create_table :posts do |t|\n      t.column :title, :string\n      t.column :content, :text\n      t.column :author_id, :integer\n    end\n    create_table :comments do |t|\n      t.column :content, :string\n      t.column :post_id, :integer\n      t.column :user_id, :integer\n    end\n  end\nend\nEOT\n")),Object(r.b)("p",null,'Next, we need to tell our ActiveRecord models about those tables and existing "foreign keys" to build associations. Here\'s another simple shell script you can copy to add those lines to our model files.'),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-shell",metastring:'title="Define the associations to the Post and Comment models"',title:'"Define',the:!0,associations:!0,to:!0,Post:!0,and:!0,Comment:!0,'models"':!0}),"sed -i '' '/.*end/i \\\n  belongs_to :author, class_name: \"User\" \\\n  has_many :comments \\\n' app/models/post.rb\n\nsed -i '' '/.*end/i \\\n  belongs_to :post \\\n  belongs_to :user \\\n' app/models/comment.rb\n")),Object(r.b)("p",null,"If it's not entirely clear what that does, simply open up the model files under ",Object(r.b)("inlineCode",{parentName:"p"},"app/models/")," to see their definition."),Object(r.b)("p",null,"And the last thing we might want to do to setup the storage layer, is to fill in the DB with some interesting data that we can query through the API. We'll keep it very short, but at least we'll have a couple of posts, authored by a couple of users, with one comment for each one. Feel free to spice this up once you're starting to have fun! Copy this shell snippet to add this code into ",Object(r.b)("inlineCode",{parentName:"p"},"db/seeds.rb")," which is always run when we seed the DB."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-shell",metastring:'title="Create some useful data when seeding the DB"',title:'"Create',some:!0,useful:!0,data:!0,when:!0,seeding:!0,the:!0,'DB"':!0}),"cat <<EOT >> db/seeds.rb\npeter = ::User.find(11)\nalice = ::User.find(12)\npost1 = ::Post.create(title: 'My first post', content: 'Post from Peter', author: peter)\npost1.comments.create(content: 'Nice post!', user: alice)\n::Post.create(content:'Post2 from Peter', author: peter)\npost2 = ::Post.create(title: 'My first post', content: 'Post from Alice', author: alice)\npost2.comments.create(content: 'Good one Alice!', user: peter)\npost3 = ::Post.create(title: 'My other post', content: 'Peter Post No Comments', author: peter)\nEOT\n")),Object(r.b)("p",null,"and with that, we are now ready (and eager) to recreate the DB, which will run the migration and seed our data:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-shell"}),"# Rebuild the DB, with the new seeds\nbundle exec rake db:recreate\n")),Object(r.b)("p",null,"Voil\xe0! We have now created the tables in the DB, configured the models to use them, and even inserted a few rows of data. We are now ready to return to Praxis and see about interacting with this data through our new API."))}d.isMDXComponent=!0},133:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),d=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(n),b=o,m=p["".concat(i,".").concat(b)]||p[b]||u[b]||r;return n?a.a.createElement(m,s(s({ref:t},c),{},{components:n})):a.a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);