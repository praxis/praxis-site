"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[2483],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3286:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const o={title:"Implementing Reads",sidebar_label:"Implementing Reads"},r=void 0,l={unversionedId:"gettingStarted/implementingReads",id:"gettingStarted/implementingReads",title:"Implementing Reads",description:"So here we are. We have designed our new API endpoints by specifying which actions we want to expose and the shapes of our Posts and Comments. We have also taken care of creating our DB structure and filling in some data to play with. Now it is time to actually implement some code that allows us to query for these resources.",source:"@site/docs/gettingStarted/implementingReads.md",sourceDirName:"gettingStarted",slug:"/gettingStarted/implementingReads",permalink:"/docs/gettingStarted/implementingReads",draft:!1,tags:[],version:"current",frontMatter:{title:"Implementing Reads",sidebar_label:"Implementing Reads"},sidebar:"mainSidebar",previous:{title:"Setting Up Our Database",permalink:"/docs/gettingStarted/settingUpOurDB"},next:{title:"Building CRUD",permalink:"/docs/gettingStarted/buildingCRUD"}},s={},p=[{value:"Implementing index and show actions",id:"implementing-index-and-show-actions",level:2},{value:"Building Filtering capabilities",id:"building-filtering-capabilities",level:2}],d={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"So here we are. We have designed our new API endpoints by specifying which actions we want to expose and the shapes of our Posts and Comments. We have also taken care of creating our DB structure and filling in some data to play with. Now it is time to actually implement some code that allows us to query for these resources."),(0,a.kt)("h2",{id:"implementing-index-and-show-actions"},"Implementing index and show actions"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"index")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"show")," actions (that search the collection and show a single element or multiple elements) are 100% implemented in the generated scaffolding code. Done and done. Not only that, but they also support field selection (similarly to GraphQL), ordering, and pagination. Don't quite believe it? Let's take our API for a spin shall we? Let's first start our app by:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"bundle exec rackup\n")),(0,a.kt)("p",null,"And now we're ready to throw some queries at it. Here are some examples you can start trying from another terminal:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'# Get all posts, but only include:\n#  -- id, contents and author (with only the author\'s first_name)\ncurl \'http://localhost:9292/posts?api_version=1\' -G \\\n      --data-urlencode "fields=id,content,author{first_name}"\n\n# Retrieve the comment with id 1, but only include:\n#  -- id, contents, related post (only id) and related user (only first_name)\ncurl \'http://localhost:9292/comments/1?api_version=1\' -G \\\n  --data-urlencode "fields=id,content,post{id},user{first_name}"\n\n# Retrieve the second page of users with a page size of 5, ordered by uuid first and then last_name\n#  -- display only their id, email and first_name\ncurl \'http://localhost:9292/users?api_version=1\' -G \\\n    --data-urlencode "fields=id,email,first_name" \\\n    --data-urlencode "order=uuid,last_name" \\\n    --data-urlencode "pagination=page=2,items=5"\n')),(0,a.kt)("p",null,"And there you go! you have a fully functioning API that is able to query items from a real DB, with support for GraphQL-style field selection, embeddable nested resources, pagination, and ordering. You're more than welcome to enable SQL logging and see how efficient the queries are...(To enable logging the easiest is to add ",(0,a.kt)("inlineCode",{parentName:"p"},"ActiveRecord::Base.logger = Logger.new(STDOUT)")," towards the end of ",(0,a.kt)("inlineCode",{parentName:"p"},"config.ru"),"). "),(0,a.kt)("p",null," Not too shabby having all this functionality without having written a single line of controller or ORM code! Did this leave you thirsty for more? Ok, challenge accepted, let's go for extra credit by showing you how you can trivially enable powerful query filtering on top of this."),(0,a.kt)("h2",{id:"building-filtering-capabilities"},"Building Filtering capabilities"),(0,a.kt)("p",null,"So to build filters with which to query elements in the ",(0,a.kt)("inlineCode",{parentName:"p"},"index")," action we need to do a couple of things:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Define the ",(0,a.kt)("inlineCode",{parentName:"li"},"filters")," parameter in the API endpoint (simply a design concern), and if you want to limit what you want to filter by, you can also specify which of the attributes you allow."),(0,a.kt)("li",{parentName:"ul"},"Tell Praxis how each of the API filters map into which underlying resource or model properties. This is only necessary if the API names and relationships have different names than the models fields and associations.")),(0,a.kt)("p",null,"Let's get started."),(0,a.kt)("p",null,"Luckily, since we've generated the endpoint using the Praxis generator, we already have en example of how to define the ",(0,a.kt)("inlineCode",{parentName:"p"},"filters")," attribute. We can just uncomment those lines and then list the attributes we want to allow for filtering. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," MediaType has an ",(0,a.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"title"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"content")," and an ",(0,a.kt)("inlineCode",{parentName:"p"},"author"),". You could, for example, allow filtering by ",(0,a.kt)("inlineCode",{parentName:"p"},"title")," (allowing wildcards), and then by author's ",(0,a.kt)("inlineCode",{parentName:"p"},"email")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"id"),". In these cases we'll only enable the ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"!=")," operators, but there are many others that are supported. To do so, we need to replace the already existing (commented out due to scaffolding) ",(0,a.kt)("inlineCode",{parentName:"p"},"filters")," parameter in the ",(0,a.kt)("inlineCode",{parentName:"p"},"design/v1/endpoints/posts.rb")," file with the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"    attribute :filters, Praxis::Types::FilteringParams.for(MediaTypes::Post) do\n       filter 'title', using: ['=', '!='], fuzzy: true\n       filter 'author.email', using: ['=', '!=']\n       filter 'author.id', using: ['=', '!=']\n    end\n")),(0,a.kt)("p",null,"And now that the endpoint is ready to accept and validate that new ",(0,a.kt)("inlineCode",{parentName:"p"},"filters")," parameter."),(0,a.kt)("p",null," In our simple case, we've designed the DB fields to match those in the API, so we don't need to specify any extra mapping of fields to match our ORM layer, we are all ready to go with our filtering. However, other APIs may have to deal with already existing DBs and ORMs that might not perfectly match the API names you wish to expose. In these cases, you simply would need to provide the conversion at the resource level. For example, if our ",(0,a.kt)("inlineCode",{parentName:"p"},"title")," API attribute of our ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," needed to be mapped to a column named ",(0,a.kt)("inlineCode",{parentName:"p"},"titulo")," in our ORM, we would simply add that conversion in a ",(0,a.kt)("inlineCode",{parentName:"p"},"filters_mapping")," function of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," resource (",(0,a.kt)("inlineCode",{parentName:"p"},"app/v1/resources/post.rb"),"). It's not our case, but here's an example of how that would look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"  filters_mapping(\n    'title': 'titulo',\n  )\n")),(0,a.kt)("p",null,"We can similarly add filtering for ",(0,a.kt)("inlineCode",{parentName:"p"},"Comments"),". For example, filtering by ",(0,a.kt)("inlineCode",{parentName:"p"},"post.id")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"user.id")," so we can easily list comments for specific posts and/or made by certain users. Or instead, for ilustration purposes, we can decide to allow filtering by any of its fields (and embedded fields). To do so, simply requires adding the same filters stanza (without a block) to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Comments")," endpoint (",(0,a.kt)("inlineCode",{parentName:"p"},"design/v1/endpoints/comments.rb"),"):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ruby"},"  attribute :filters, Praxis::Types::FilteringParams.for(MediaTypes::Comment)\n")),(0,a.kt)("p",null,"So, that's essentially it. What!? There is still no need to build any controller or ORM queries? Nope, that's the power of following the best practices and adding the extensions. Let's give it a whirl!"),(0,a.kt)("p",null,"First let's make sure we start (or restart) the API server with ",(0,a.kt)("inlineCode",{parentName:"p"},"bundle exec rackup"),". Then, from another terminal, let's get all ",(0,a.kt)("inlineCode",{parentName:"p"},"posts")," that were written by ",(0,a.kt)("inlineCode",{parentName:"p"},"peter@pan.com")," (We know there are some with this email in our seeds):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'# Get all posts written by an author with email=peter@pan.com:\n#  -- id, contents and author (with only first_name)\ncurl \'http://localhost:9292/posts?api_version=1\' -G \\\n      --data-urlencode "filters=author.email=peter@pan.com" \\\n      --data-urlencode "fields=id,title,content,author{first_name}"\n')),(0,a.kt)("p",null,"Or we can combine multiple filters at once. For example, let's get posts that contain the word ",(0,a.kt)("inlineCode",{parentName:"p"},"first")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"title")," AND that have been written by authors with ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," 11 OR 12 (which we know they are Peter and Alice, from the seeds)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'# Get all posts that contain `first` in the title, written by an author with id 11 or 12:\n#  -- id, contents and author (with only first_name)\ncurl \'http://localhost:9292/posts?api_version=1\' -G \\\n      --data-urlencode "filters=title=*first*&author.id=11,12" \\\n      --data-urlencode "fields=id,title,content,author{first_name}"\n')),(0,a.kt)("p",null,"And there you go. Notice two things here: one is that multiple filters are separated by an ",(0,a.kt)("inlineCode",{parentName:"p"},"&"),", and also equality filters support an array of values, separated by commas (",(0,a.kt)("inlineCode",{parentName:"p"},"author.id=11,12"),") which will translate into something like ",(0,a.kt)("inlineCode",{parentName:"p"},"...WHERE authod_id IN (11,12)..."),". Also, this is just the tip of the iceberg with what you can do with filters. Suffice to say for now that it supports AND, OR with the right precedence, including grouping sub-clauses with parenthesis. It also supports all kinds of operators including equality, inequality, greater/smaller, NULL, not NULL, empty/not-empty collection relationships, and even fuzzy (prefix/suffix) regexp. Pretty powerful for being something that requires no coding whatsoever."),(0,a.kt)("p",null,"Well, at this point we have built a fully featured read-only API that allows us to retrieve users, posts, and comments; which supports field selection (including nested relationships); which can paginate and sort; and which supports all a wide range of filtering. All of it, without writing a single line of controller code or any explicit ORM queries. Talk about development efficiency!"),(0,a.kt)("p",null,"The next logical step you might be thinking of is: what about the CRUD operations? I'm glad you asked, let's dig in."))}c.isMDXComponent=!0}}]);