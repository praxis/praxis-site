"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"mainSidebar":[{"type":"category","label":"Getting Started","collapsed":true,"items":[{"type":"link","label":"Intro","href":"/docs/gettingStarted/intro","docId":"gettingStarted/intro"},{"type":"link","label":"Designing our API resources","href":"/docs/gettingStarted/designingApiResources","docId":"gettingStarted/designingApiResources"},{"type":"link","label":"Setting Up Our Database","href":"/docs/gettingStarted/settingUpOurDB","docId":"gettingStarted/settingUpOurDB"},{"type":"link","label":"Implementing Reads","href":"/docs/gettingStarted/implementingReads","docId":"gettingStarted/implementingReads"},{"type":"link","label":"Building CRUD","href":"/docs/gettingStarted/buildingCRUD","docId":"gettingStarted/buildingCRUD"}],"collapsible":true},{"type":"category","label":"Reference","collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/reference/intro","docId":"reference/intro"},{"type":"category","label":"Design","items":[{"type":"link","label":"Media Types","href":"/docs/reference/design/media-types","docId":"reference/design/media-types"},{"type":"link","label":"Endpoints","href":"/docs/reference/design/endpoints","docId":"reference/design/endpoints"},{"type":"link","label":"Actions","href":"/docs/reference/design/actions","docId":"reference/design/actions"},{"type":"link","label":"General API Definitions","href":"/docs/reference/design/api-definition","docId":"reference/design/api-definition"},{"type":"link","label":"Responses","href":"/docs/reference/design/response-definitions","docId":"reference/design/response-definitions"},{"type":"link","label":"Traits","href":"/docs/reference/design/traits","docId":"reference/design/traits"},{"type":"link","label":"Document Generation","href":"/docs/reference/design/doc-generation","docId":"reference/design/doc-generation"},{"type":"link","label":"Multipart","href":"/docs/reference/design/multipart","docId":"reference/design/multipart"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Implementation","items":[{"type":"link","label":"Controllers","href":"/docs/reference/implementation/controllers","docId":"reference/implementation/controllers"},{"type":"link","label":"Resources","href":"/docs/reference/implementation/resources","docId":"reference/implementation/resources"},{"type":"link","label":"Application","href":"/docs/reference/implementation/application","docId":"reference/implementation/application"},{"type":"link","label":"Responses","href":"/docs/reference/implementation/responses","docId":"reference/implementation/responses"},{"type":"link","label":"Request Life Cycle","href":"/docs/reference/implementation/request-life-cycle","docId":"reference/implementation/request-life-cycle"},{"type":"link","label":"Multipart Types","href":"/docs/reference/implementation/multipart","docId":"reference/implementation/multipart"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Extensions","items":[{"type":"link","label":"Introduction","href":"/docs/reference/extensions/intro","docId":"reference/extensions/intro"},{"type":"link","label":"Mapper Plugin","href":"/docs/reference/extensions/mapper-plugin","docId":"reference/extensions/mapper-plugin"},{"type":"link","label":"Pagination Plugin","href":"/docs/reference/extensions/pagination-plugin","docId":"reference/extensions/pagination-plugin"},{"type":"link","label":"Field Selection","href":"/docs/reference/extensions/field-selection","docId":"reference/extensions/field-selection"},{"type":"link","label":"Filtering","href":"/docs/reference/extensions/filtering","docId":"reference/extensions/filtering"},{"type":"link","label":"Rendering","href":"/docs/reference/extensions/rendering","docId":"reference/extensions/rendering"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Internals","items":[{"type":"link","label":"Introduction","href":"/docs/reference/internals/intro","docId":"reference/internals/intro"},{"type":"link","label":"FieldSelection","href":"/docs/reference/internals/field_selection","docId":"reference/internals/field_selection"},{"type":"link","label":"FieldExpansion","href":"/docs/reference/internals/field_expansion","docId":"reference/internals/field_expansion"},{"type":"link","label":"MapperSelectors","href":"/docs/reference/internals/mapper_selectors","docId":"reference/internals/mapper_selectors"},{"type":"link","label":"Bootstrapping","href":"/docs/reference/internals/bootstrapping","docId":"reference/internals/bootstrapping"},{"type":"link","label":"Handlers","href":"/docs/reference/internals/handlers","docId":"reference/internals/handlers"}],"collapsed":true,"collapsible":true}],"collapsible":true}]},"docs":{"gettingStarted/buildingCRUD":{"id":"gettingStarted/buildingCRUD","title":"Building CRUD","description":"The way that people build CRUD operations often varies more than read-only operations like index and show. However, Praxis still brings in many best practices (and helper tools) that you can decide to follow. You can also decide not to follow these practices and implement your controller code however you see fit otherwise. That\'s one of the main goals of Praxis: at the core, it provides a solid Web API routing/parameter/controller Rack-based framework you can directly use (i.e., a la Sinatra), but you can easily opt-in to as many other extensions and best practices as you want (and you can even do it on a controller by controller basis, etc.)","sidebar":"mainSidebar"},"gettingStarted/designingApiResources":{"id":"gettingStarted/designingApiResources","title":"Designing our API resources","description":"Our goal is to build an API that contains Posts and embedded Comments. So let\'s first scaffold the design part for them. To do so, the easiest way is to use the Praxis scaffold generator, so let\'s do that:","sidebar":"mainSidebar"},"gettingStarted/implementingReads":{"id":"gettingStarted/implementingReads","title":"Implementing Reads","description":"So here we are. We have designed our new API endpoints by specifying which actions we want to expose and the shapes of our Posts and Comments. We have also taken care of creating our DB structure and filling in some data to play with. Now it is time to actually implement some code that allows us to query for these resources.","sidebar":"mainSidebar"},"gettingStarted/intro":{"id":"gettingStarted/intro","title":"Intro","description":"So you\'re new to Praxis, you\'ve read some of the interesting stuff that it can do and","sidebar":"mainSidebar"},"gettingStarted/settingUpOurDB":{"id":"gettingStarted/settingUpOurDB","title":"Setting Up Our Database","description":"Evidently, we want our API to provide some data. To achieve that we need to have a DB with the proper posts and comments tables, and ideally populated with some interesting bits. This part has nothing to do with Praxis, yet it still needs to be done! Note that if you\'re building a Praxis API to serve data from an already existing DB, the only thing you need to do is to configure your models to point to it. Or even better, if you\'re building a Praxis API to serve already existing models within a Rails app, none of this needs to be done, as it\'s already in place. You can read more about how to build this within an existing Rails app in the documentation for the  MiddlewareApp module.","sidebar":"mainSidebar"},"reference/design/actions":{"id":"reference/design/actions","title":"Actions","description":"Each of the available actions for an endpoint are defined using the action method. At a minimum, an action definition must have a name and at least one route. It\'s a good idea to add a description for each action so Praxis can use it when generating documentation. In addition to a description an action can also specify:","sidebar":"mainSidebar"},"reference/design/api-definition":{"id":"reference/design/api-definition","title":"General API Definitions","description":"There are certain things in an API that are common across all or many endpoints and actions. Praxis\' ApiDefinition class is a singleton that allows you do exactly that","sidebar":"mainSidebar"},"reference/design/doc-generation":{"id":"reference/design/doc-generation","title":"Document Generation","description":"Praxis makes it easy to generate documentation for your app. To generate","sidebar":"mainSidebar"},"reference/design/endpoints":{"id":"reference/design/endpoints","title":"Endpoints","description":"With Praxis, you can define all of the API endpoints that your API provides. An endpoint is commonly a set of API actions that are related to a given resource type or related set of actions. i.e., the Users endpoint might define all the actions to list, create and update users.","sidebar":"mainSidebar"},"reference/design/media-types":{"id":"reference/design/media-types","title":"Media Types","description":"Media types provide the structural representation of the API resources we want to expose. They also commonly have an associated name (i.e., its identifier).","sidebar":"mainSidebar"},"reference/design/multipart":{"id":"reference/design/multipart","title":"Multipart","description":"Praxis has built-in support for defining and handling \\"multipart/form-data\\" requests and responses (rfc2388 & friends). This support is mostly provided by the underlying Praxis::MultipartOk response.","sidebar":"mainSidebar"},"reference/design/response-definitions":{"id":"reference/design/response-definitions","title":"Responses","description":"Praxis allows API designers to define the set of response templates the","sidebar":"mainSidebar"},"reference/design/traits":{"id":"reference/design/traits","title":"Traits","description":"Sometimes one wants to reuse common definition functionality across your entire API, which can be applied across different endpoints and actions. Praxis has the concept of Traits, to achieve this goal.","sidebar":"mainSidebar"},"reference/extensions/field-selection":{"id":"reference/extensions/field-selection","title":"Field Selection","description":"One of the most important Praxis extensions is the ability to select which fields of the response objects you want to receive. Using this extension, an API client is able to fully specify (through a graphQL syntax) which fields to retrieve. This functionality, along with the GraphQL syntax allows you to recurse as deep as you need it to describe the complete tree of data that you want to retrieve using only a single API request.","sidebar":"mainSidebar"},"reference/extensions/filtering":{"id":"reference/extensions/filtering","title":"Filtering","description":"The filtering extensions, along with the field selection and the automatic DB querying is a powerful tool that makes it trivial for API clients to slice and dice what data to retrieve.","sidebar":"mainSidebar"},"reference/extensions/intro":{"id":"reference/extensions/intro","title":"Introduction","description":"Praxis is to be a high productivity framework where you can immediatly leverage many framework features to guide you and allow you to move really fast. At the same time, however, the philosophy of Praxis is to also keep all of those extensions and building blocks as optional. It is our goal, building it in this way it can give the best of both worlds, as you can always decide to customize, change or combine the pieces that make more sense to you as your application changes and evolves.","sidebar":"mainSidebar"},"reference/extensions/mapper-plugin":{"id":"reference/extensions/mapper-plugin","title":"Mapper Plugin","description":"The MapperPlugin plugin is a \'meta\'-extension that will configure several of the common feature extensions to work together with minimal effort.","sidebar":"mainSidebar"},"reference/extensions/pagination-plugin":{"id":"reference/extensions/pagination-plugin","title":"Pagination Plugin","description":"The PaginationPlugin plugin is a \'meta\'-extension that brings in the pagination and ordering extensions.","sidebar":"mainSidebar"},"reference/extensions/rendering":{"id":"reference/extensions/rendering","title":"Rendering","description":"The Rendering extension adds render and display helper methods to controllers. These functions reduce common boilerplate when producing rendered representations of media types and setting response \\"Content-Type\\" headers.","sidebar":"mainSidebar"},"reference/implementation/application":{"id":"reference/implementation/application","title":"Application","description":"Praxis allows certain application-wide level configuration and customization options.","sidebar":"mainSidebar"},"reference/implementation/controllers":{"id":"reference/implementation/controllers","title":"Controllers","description":"Controllers are the entrypoint where the implementation to fulfill all API requests live.","sidebar":"mainSidebar"},"reference/implementation/multipart":{"id":"reference/implementation/multipart","title":"Multipart Types","description":"Praxis does not only have multipart support for the design of your API, but it also provides some classes that allow you to read and generate proper multipart structures. The majority of that is still encapsulated in the MultipartArray class, the same one used in the design pieces.","sidebar":"mainSidebar"},"reference/implementation/request-life-cycle":{"id":"reference/implementation/request-life-cycle","title":"Request Life Cycle","description":"Praxis processes each incoming request by funneling them through a pipeline of stages. Stages are execution points during the servicing of a request, which could themselves contain a set of sub-stages. Each registered stage has a unique name and is connected to the other stages in a well-known order.","sidebar":"mainSidebar"},"reference/implementation/resources":{"id":"reference/implementation/resources","title":"Resources","description":"TODO!!","sidebar":"mainSidebar"},"reference/implementation/responses":{"id":"reference/implementation/responses","title":"Responses","description":"The main goal for an API service is to return the right HTTP responses to the client. There are many different types API response, with many different HTTP codes, different types of payload encodings, headers...etc.","sidebar":"mainSidebar"},"reference/internals/bootstrapping":{"id":"reference/internals/bootstrapping","title":"Bootstrapping","description":"Coming soon!","sidebar":"mainSidebar"},"reference/internals/field_expansion":{"id":"reference/internals/field_expansion","title":"FieldExpansion","description":"The FieldExpansion extension is an internal extension that helps connect the field selection with the querying functionality. It provides a Controller#expandedfields helper determine the final set of fields necessary to process the request. This is necessary because you are not required to fully expand all fields to leaf nodes. For example, you can ask to render id,author fields, where the author attribute can map to a User mediatype with many attributes and other related mediatypes. In this case, one needs to fully expend the author to the set of attributes defined in the defaultfieldset of a User. This is what the Field expanded does.","sidebar":"mainSidebar"},"reference/internals/field_selection":{"id":"reference/internals/field_selection","title":"FieldSelection","description":"The FieldSelection extension adds an enhanced version of the  Attributor::FieldSelector). This may be used both generically (i.e., directly as FieldSelector), or scoped to a specific MediaType with FieldSelector.for so that it can perform validation.","sidebar":"mainSidebar"},"reference/internals/handlers":{"id":"reference/internals/handlers","title":"Handlers","description":"Coming soon!","sidebar":"mainSidebar"},"reference/internals/intro":{"id":"reference/internals/intro","title":"Introduction","description":"This section is a bit of a kitchen sink that has some low-level details on some of the underpinning types and classes that the framework uses for the extensions.","sidebar":"mainSidebar"},"reference/internals/mapper_selectors":{"id":"reference/internals/mapper_selectors","title":"MapperSelectors","description":"The MapperSelectors extension type is in charge of mapping the required fields from the API (after having been expanded by the FieldExpansion extension, to tables, associations and columns in the Datastore.","sidebar":"mainSidebar"},"reference/intro":{"id":"reference/intro","title":"Introduction","description":"TODO:","sidebar":"mainSidebar"}}}')}}]);