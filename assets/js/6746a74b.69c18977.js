"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[8722],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),s=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(o.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(a),m=r,h=u["".concat(o,".").concat(m)]||u[m]||c[m]||i;return a?n.createElement(h,p(p({ref:t},d),{},{components:a})):n.createElement(h,p({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,p=new Array(i);p[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[u]="string"==typeof e?e:r,p[1]=l;for(var s=2;s<i;s++)p[s]=a[s];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5848:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>p,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const i={title:"Multipart Types"},p=void 0,l={unversionedId:"reference/implementation/multipart",id:"reference/implementation/multipart",title:"Multipart Types",description:"Praxis does not only have multipart support for the design of your API, but it also provides some classes that allow you to read and generate proper multipart structures. The majority of that is still encapsulated in the MultipartArray class, the same one used in the design pieces.",source:"@site/docs/reference/implementation/multipart.md",sourceDirName:"reference/implementation",slug:"/reference/implementation/multipart",permalink:"/docs/reference/implementation/multipart",draft:!1,tags:[],version:"current",frontMatter:{title:"Multipart Types"},sidebar:"mainSidebar",previous:{title:"Request Life Cycle",permalink:"/docs/reference/implementation/request-life-cycle"},next:{title:"Introduction",permalink:"/docs/reference/extensions/intro"}},o={},s=[{value:"Multipart Responses",id:"multipart-responses",level:2},{value:"Parsing multipart object",id:"parsing-multipart-object",level:2},{value:"Crafting MultipartArray objects",id:"crafting-multipartarray-objects",level:2}],d={toc:s},u="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Praxis does not only have multipart support for the design of your API, but it also provides some classes that allow you to read and generate proper multipart structures. The majority of that is still encapsulated in the ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartArray")," class, the same one used in the design pieces."),(0,r.kt)("h2",{id:"multipart-responses"},"Multipart Responses"),(0,r.kt)("p",null,"Praxis also provides support for generating multipart responses. In particular, Praxis provides:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"an ",(0,r.kt)("inlineCode",{parentName:"li"},"add_parts")," accessor in ",(0,r.kt)("inlineCode",{parentName:"li"},"Praxis::Response")," to add parts to be returned in\na response."),(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("inlineCode",{parentName:"li"},"parts")," accessor in ",(0,r.kt)("inlineCode",{parentName:"li"},"Praxis::Response")," to list the parts contained in a\nresponse."),(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("inlineCode",{parentName:"li"},"Praxis::MultipartPart")," class to represent and format individual parts")),(0,r.kt)("p",null,"Here's an example of how to create a multipart response containing two parts named 'part1' and 'part2', oth use the 'text/plain' Content-Type. NOTE: We're assuming the structure of the multipart body to return is defined in a class elsewhere (i.e., ",(0,r.kt)("inlineCode",{parentName:"p"},"MyDefinedMultipartResponseClass"),"), and that obviously the Parts we're adding will correspond and be valid according to that."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'# This response directly defines a 200 status and a media_type of multipart/form-data\nresponse = Praxis::Responses::MultipartOk.new\nresponse.body = MyDefinedMultipartResponseClass.new\n\nplain_headers = {\'Content-Type\' => \'text/plain\'}\n\npart1 = Praxis::MultipartPart.new("this is part 1", plain_headers)\nresponse.add_part("part1", part1)\n\npart2 = Praxis::MultipartPart.new("this is part 2", plain_headers)\nresponse.add_part("part2", part2)\n')),(0,r.kt)("p",null,"There is a specialized ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartOk")," response class is used to easily return a ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartArray"),' body.\nIt just simply takes care of properly encoding the body as "multipart/form-data", with a proper "Content-Type"\nheader specifying the boundary of each part. The response is registered as ',(0,r.kt)("inlineCode",{parentName:"p"},":multipart_ok"),"."),(0,r.kt)("p",null,'Upon rendering, this response class will also take care of properly dumping each parts according to its "Content-Type" header, using any applicable handlers registered with Praxis. See ',(0,r.kt)("a",{parentName:"p",href:"../internals/handlers/"},(0,r.kt)("inlineCode",{parentName:"a"},"Handlers"))," for more details on how to define and\nregister custom handlers."),(0,r.kt)("h2",{id:"parsing-multipart-object"},"Parsing multipart object"),(0,r.kt)("p",null,"If we are trying to inspect an instance of a ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartArray")," (i.e., a ",(0,r.kt)("inlineCode",{parentName:"p"},"request.payload")," object when that's defined a one), we have two options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"retrieve a part by name using ",(0,r.kt)("inlineCode",{parentName:"li"},".part(name)")," method. This usually results in a single ",(0,r.kt)("inlineCode",{parentName:"li"},"MultipartPart")," instance. However, you will get an array of ",(0,r.kt)("inlineCode",{parentName:"li"},"MultipartPart")," instances, if such part has been defined with the ",(0,r.kt)("inlineCode",{parentName:"li"},"multiple: true")," option"),(0,r.kt)("li",{parentName:"ul"},"consider the object as an array of parts, and use the standard Ruby ",(0,r.kt)("inlineCode",{parentName:"li"},"Array")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Enumerable")," methods. In this case you will get an instance of ",(0,r.kt)("inlineCode",{parentName:"li"},"MultipartPart")," everytime (potentially with repeated part names if there were indeed multiple part with the same name).")),(0,r.kt)("h2",{id:"crafting-multipartarray-objects"},"Crafting MultipartArray objects"),(0,r.kt)("p",null,"To create a ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartArray")," instance we can simply instantiate the object from the class, and start adding ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartPart")," instances through use ",(0,r.kt)("inlineCode",{parentName:"p"},"push(part)")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"push(*parts)"),". Doing so it will validate the part names and coerce any headers and payload as applicable."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartPart")," object have the following methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload"),": the part body data"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"headers"),": hash of headers"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name"),": part name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filename"),": filename, if applicable")),(0,r.kt)("p",null,"Here you have an example action that shows how to read and genarate multipart payloads. This silly action will loop over the parts received in the action, and will generate an outgoing multipart response that has as many parts as received. Each of the generated parts will have a simple string body and a ",(0,r.kt)("inlineCode",{parentName:"p"},"Special")," header as well.  Note that this assumes the ",(0,r.kt)("inlineCode",{parentName:"p"},"bulk_create")," action has been defined as receiving a ",(0,r.kt)("inlineCode",{parentName:"p"},"MultipartArray")," payload, which supports the ",(0,r.kt)("inlineCode",{parentName:"p"},".each")," method to loop over the individual parts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"def bulk_create\n  self.response = Praxis::Responses::MultipartOk.new\n  # For demonstration purposes, reach out to the multipart type defined for this action\n  # and instantiate it here. Typically this type would probably be defined and reused from elsewhere\n  self.response.body = request.action.responses[:multipart_ok].media_type.new\n\n  # Loop over each incoming part, and generate an outgoing part for each\n  request.payload.each do |part_name, part|\n    part = Praxis::MultipartPart.new(\"the part body\", name: part_name, {'Special' => 'header'})\n\n    response.add_part(part_name, part)\n  end\n  \n  response\nend\n")))}c.isMDXComponent=!0}}]);