"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[6094],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=i,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7505:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={title:"Filtering"},o=void 0,l={unversionedId:"reference/extensions/filtering",id:"reference/extensions/filtering",title:"Filtering",description:"The filtering extensions, along with the field selection and the automatic DB querying is a powerful tool that makes it trivial for API clients to slice and dice what data to retrieve.",source:"@site/docs/reference/extensions/filtering.md",sourceDirName:"reference/extensions",slug:"/reference/extensions/filtering",permalink:"/docs/reference/extensions/filtering",draft:!1,tags:[],version:"current",frontMatter:{title:"Filtering"},sidebar:"mainSidebar",previous:{title:"Field Selection",permalink:"/docs/reference/extensions/field-selection"},next:{title:"Rendering",permalink:"/docs/reference/extensions/rendering"}},s={},p=[{value:"FilteringParams type",id:"filteringparams-type",level:2}],d={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The filtering extensions, along with the field selection and the automatic DB querying is a powerful tool that makes it trivial for API clients to slice and dice what data to retrieve."),(0,i.kt)("p",null,"To take advantage of this extension you just need to do two things. First add which attributes you want to allow to filter by in your action design, and second, provide the mapping from these filter names, to the names of the underlying associations and/or database columns. Let's take a look at what this means before we get into the details."),(0,i.kt)("p",null,"Let's assume you want to allow to filter your ",(0,i.kt)("inlineCode",{parentName:"p"},"Posts")," by their ",(0,i.kt)("inlineCode",{parentName:"p"},"title"),", or by their author's ",(0,i.kt)("inlineCode",{parentName:"p"},"email")," or by the date is was ",(0,i.kt)("inlineCode",{parentName:"p"},"posted_at"),". To do so, you'd define a ",(0,i.kt)("inlineCode",{parentName:"p"},"filters")," param (typically in the ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," action) much like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"  params do\n    attribute :filters, Praxis::Types::FilteringParams.for(MediaTypes::Post) do\n              filter 'title', using: ['=', '!='], fuzzy: true\n              filter 'author.email', using: ['=', '!=']\n              filter 'posted_at', using: ['=', '!=','>','<','>=','=<']\n    end\n  end\n")),(0,i.kt)("p",null,"Note that we've made some decisions here, about restricting which operators we allow for each filter, including deciding that we can allow the client for filter by prefix/postfix on the title (i.e., a ",(0,i.kt)("inlineCode",{parentName:"p"},"LIKE")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"REGEXP"),"-type condition)."),(0,i.kt)("p",null,"In your Resource business logic, you also have to define how these API filter names might map differently to the lower level DB columns of your data. In this case, we can see that the ",(0,i.kt)("inlineCode",{parentName:"p"},"title")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"posted_at")," filters map to the same column names. We can also see that we need to map the author's email filter, to an underlying ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," association, and a ",(0,i.kt)("inlineCode",{parentName:"p"},"email_address")," column. In other words, the mapping can traverse associations and/or map to names of columns that might or might not coincide with the filter names used. For simplicity, Praxis allows you to omit mapping simple names that concide (so we could have perfectly omitted ",(0,i.kt)("inlineCode",{parentName:"p"},"title")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"posted_at")," in this example.) Note that omission is for 'simple' fields, you still need to define mappings for any nested field even if they both map to the same(i.e., 'user.id' => 'user.id' still needs to defined )."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"    filters_mapping(\n      'title': 'title',\n      'author.email': 'user.email_address',\n      'posted_at': 'posted_at',\n    )\n")),(0,i.kt)("h2",{id:"filteringparams-type"},"FilteringParams type"),(0,i.kt)("p",null,"Every filter defined in the Filtering params type can declare:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the exposed name of the filter"),(0,i.kt)("li",{parentName:"ul"},"the operators that are allowed to use"),(0,i.kt)("li",{parentName:"ul"},"and if they can be used to do prefix/suffix matching.")),(0,i.kt)("p",null,"When you use the ",(0,i.kt)("inlineCode",{parentName:"p"},".for")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"FilteringParams")," type, the defined filter names must correspond to fields of the mediatype. These names can recurse down into other related fields of the mediatypes, all the way down to the final condition. In other words, filtering is not restricted to a direct attribute, or a single nested level. The only way to provide filter names that do not map to the mediatype would be to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"FilteringParams")," type without the ",(0,i.kt)("inlineCode",{parentName:"p"},".for")," method, and properly build your parsing and coercion of attributes."),(0,i.kt)("p",null,"There are 8 available operators to choose from: ",(0,i.kt)("inlineCode",{parentName:"p"},"="),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},">"),",",(0,i.kt)("inlineCode",{parentName:"p"},"!="),", ",(0,i.kt)("inlineCode",{parentName:"p"},">="),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,i.kt)("inlineCode",{parentName:"p"},"!"),",",(0,i.kt)("inlineCode",{parentName:"p"},"!!"),". The first 6 are seemingly self explanatory and always take a value (i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"filter_name>value"),"). The last 2 operators are for checking NULL (or NOT NULL) values and do not accept a value. In particular:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"filter_name!")," would filter results whose ",(0,i.kt)("inlineCode",{parentName:"li"},"filter_name is NOT NULL")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"filter_name!!")," would filter results whose ",(0,i.kt)("inlineCode",{parentName:"li"},"filter_name is NULL"))),(0,i.kt)("p",null,"Something important to point out, is that the filtering framework also allows to place conditions on associations directly (instead of leaf attributes). This powerful feature (only available for the ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!!")," operators) allows filtering results where full collections of related objects are empty, or are not empty. For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"author!")," would return only Posts which have associated authors."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"comments!!")," would return only Posts which have no associated comments")),(0,i.kt)("p",null,"Filters for string attributes, can also accept a ",(0,i.kt)("inlineCode",{parentName:"p"},"fuzzy: true")," option, which would allow to prefix or postfix patch the value. For example, using our ",(0,i.kt)("inlineCode",{parentName:"p"},"title")," filter above would allow us to do things like this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"title=*ending"),", which will translate to a SQL query similar to ",(0,i.kt)("inlineCode",{parentName:"li"},'LIKE "%ending"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"title=starting*"),", which will translate to a SQL query similar to ",(0,i.kt)("inlineCode",{parentName:"li"},'LIKE "starting%"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"title=*Iam%20a%2A%21")," (whose encoded value after the ",(0,i.kt)("inlineCode",{parentName:"li"},"*")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"Iam a*!"),") which will translate to a SQL query similar to ",(0,i.kt)("inlineCode",{parentName:"li"},'LIKE "%Iam a*!"'))),(0,i.kt)("p",null,"A filter condition generally has a single value, but Praxis allows you to pass a comma-separated list of values as a compact way to do a multimatch without requiring several clauses. These will generally be translated to ",(0,i.kt)("inlineCode",{parentName:"p"},"IN clause")," SQL queries. Here is an example some examples:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"author.email=one%40example.com,two%40example.com"),", which will typically translate into ",(0,i.kt)("inlineCode",{parentName:"li"},"... email_address IN ('one@example.com', 'one@example.com)"))),(0,i.kt)("p",null,'Remember that we need to always escape the filter values. This multi-map case is no different, so we will do so for each of them but not the "commas" as that\'s part of the filter syntax. Also note that all of the resulting string of the ',(0,i.kt)("inlineCode",{parentName:"p"},"filters")," value will also be url-encoded when forming the query string of the API request."),(0,i.kt)("p",null,"The syntax allows you to to combine multiple filter conditions in the same API call. In fact, it is possible to combine them with ",(0,i.kt)("inlineCode",{parentName:"p"},"AND"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"OR")," operands, as well as group them with parenthesis. The precedence of operands is exactly what you'd expect, where ",(0,i.kt)("inlineCode",{parentName:"p"},"AND")," has higher-precedence than ",(0,i.kt)("inlineCode",{parentName:"p"},"OR")," unless there are parenthesized groups defining an element."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&")," is used to ",(0,i.kt)("inlineCode",{parentName:"li"},"AND")," two filters and/or expressions. For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"title=one&posted_at>2000-01-01")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"|")," is used to ",(0,i.kt)("inlineCode",{parentName:"li"},"OR")," two filters and/or expressions. For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"title=one|author.email=email1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"(")," and ",(0,i.kt)("inlineCode",{parentName:"li"},")")," are used to group one or more filter conditions. For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"(a=1|b=2)&c=3&d=4"))),(0,i.kt)("p",null,"Not to repeat ourselves too much, but obviously do not escape these symbols when used in this mode. Only escape them when they are part of a value."))}u.isMDXComponent=!0}}]);