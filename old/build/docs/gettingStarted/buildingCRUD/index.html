<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Praxis Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Praxis Blog Atom Feed"><title data-react-helmet="true">Building CRUD | Praxis</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Building CRUD | Praxis"><meta data-react-helmet="true" name="description" content="The way that people build CRUD operations often varies more than read-only operations like index and show. However, Praxis still brings in many best practices (and helper tools) that you can decide to follow. You can also decide not to follow these practices and implement your controller code however you see fit otherwise. That&#x27;s one of the main goals of Praxis: at the core, it provides a solid Web API routing/parameter/controller Rack-based framework you can directly use (i.e., a la Sinatra), but you can easily opt-in to as many other extensions and best practices as you want (and you can even do it on a controller by controller basis, etc.)"><meta data-react-helmet="true" property="og:description" content="The way that people build CRUD operations often varies more than read-only operations like index and show. However, Praxis still brings in many best practices (and helper tools) that you can decide to follow. You can also decide not to follow these practices and implement your controller code however you see fit otherwise. That&#x27;s one of the main goals of Praxis: at the core, it provides a solid Web API routing/parameter/controller Rack-based framework you can directly use (i.e., a la Sinatra), but you can easily opt-in to as many other extensions and best practices as you want (and you can even do it on a controller by controller basis, etc.)"><meta data-react-helmet="true" property="og:url" content="https://www.praxis-framework.io/docs/gettingStarted/buildingCRUD"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://www.praxis-framework.io/docs/gettingStarted/buildingCRUD"><link rel="stylesheet" href="/styles.ab2c79ee.css">
<link rel="preload" href="/styles.27a80096.js" as="script">
<link rel="preload" href="/runtime~main.d759ace7.js" as="script">
<link rel="preload" href="/main.0f7e767c.js" as="script">
<link rel="preload" href="/1.1d955ac3.js" as="script">
<link rel="preload" href="/65.fc2dba12.js" as="script">
<link rel="preload" href="/66.81df1f16.js" as="script">
<link rel="preload" href="/935f2afb.f1e5e5bf.js" as="script">
<link rel="preload" href="/64.4c9a6482.js" as="script">
<link rel="preload" href="/c498de60.b6b7fd24.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Praxis Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.png" alt="Praxis Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Praxis</strong></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/gettingStarted/intro">Getting Started</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/reference/intro">Reference</a><a href="https://github.com/praxis/praxis" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="Praxis Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.png" alt="Praxis Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Praxis</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/gettingStarted/intro">Getting Started</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/reference/intro">Reference</a></li><li class="menu__list-item"><a href="https://github.com/praxis/praxis" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Intro</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/intro/intro">Intro</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/intro/installation">Installation</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Getting Started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/gettingStarted/intro">Intro</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/gettingStarted/designingApiResources">Designing our API resources</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/gettingStarted/settingUpOurDB">Setting Up Our Database</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/gettingStarted/implementingReads">Implementing Reads</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/gettingStarted/buildingCRUD">Building CRUD</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Reference</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/intro">Introduction</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Design</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/media-types">Media Types</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/endpoints">Endpoints</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/actions">Actions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/api-definition">General API Definitions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/response-definitions">Responses</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/traits">Traits</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/doc-generation">Document Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/design/multipart">Multipart</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Implementation</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/implementation/controllers">Controllers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/implementation/application">Application</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/implementation/responses">Responses</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/implementation/request-life-cycle">Request Life Cycle</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/implementation/multipart">Multipart Types</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Extensions</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/extensions/intro">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/extensions/mapper-plugin">Mapper Plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/extensions/pagination-plugin">Pagination Plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/extensions/field-selection">Field Selection</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/extensions/filtering">Filtering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/extensions/rendering">Rendering</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Internals</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/internals/intro">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/internals/field_selection">FieldSelection</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/internals/field_expansion">FieldExpansion</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/reference/internals/mapper_selectors">MapperSelectors</a></li></ul></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_2WRA"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_CoMu"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">Building CRUD</h1></header><div class="markdown"><p>The way that people build CRUD operations often varies more than read-only operations like <code>index</code> and <code>show</code>. However, Praxis still brings in many best practices (and helper tools) that you can decide to follow. You can also decide not to follow these practices and implement your controller code however you see fit otherwise. That&#x27;s one of the main goals of Praxis: at the core, it provides a solid Web API routing/parameter/controller Rack-based framework you can directly use (i.e., a la Sinatra), but you can easily opt-in to as many other extensions and best practices as you want (and you can even do it on a controller by controller basis, etc.)</p><p>But anyway, we were talking about implementing the CRUD operations weren&#x27;t we? Let&#x27;s go through it one by one, first <code>update</code>, then <code>create</code>, and finally, <code>delete</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="update"></a>Update<a class="hash-link" href="#update" title="Direct link to heading">#</a></h2><p>Like always, we start by defining the API design of our new action.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="designing-update"></a>Designing Update<a class="hash-link" href="#designing-update" title="Direct link to heading">#</a></h3><p>For that, let&#x27;s take a look at the scaffolded code from our generator:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  action :update do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    description &#x27;Update one or more attributes of an existing Post&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    routing { patch &#x27;/:id&#x27; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    params do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      attribute :id, required: true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    payload reference: MediaTypes::Post do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # List the attributes you accept from the one existing in the Post Mediatype</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # and/or fully define any other ones you allow to change</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # attribute :name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    response :no_content</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    response :bad_request</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>This defines that an update will be done through a <code>PATCH</code> request to the member url of the posts collection (<code>/posts/:id</code>), where <code>:id</code> is the given identifier of the post to update. As a response, the client can expect a <code>204 No Content</code> when successful update or a <code>400 Bad Request</code> if the request couldn&#x27;t be completed (which will include information as to why it failed). Looks pretty reasonable so far.</p><p>Notice that query-string parameters are defined separately from body parameters. Query string parameters are defined in the <code>params</code> block of the design, while request body structure is defined in the <code>payload</code> block. In this case we will be defining the payload as a simple incoming hash-like structure, but bear in mind that it can be designed to accept arrays, and/or complex multipart bodies, etc.</p><p>The only thing that we need to modify from the scaffold code is the payload, as it contains the attributes we want to allow the client to update. You are obviously free to choose the shape and names of that structure. However, a Praxis best practice is to design incoming payload structures that mimic the rendered corresponding output MediaType (i.e., trying to have INPUTS == OUTPUTS as much as possible). To follow that tenet, we want to accept a payload that has <code>title</code>, <code>contents</code> (and potentially an <code>author</code>), given that these are the only three existing attributes of a <code>Post</code>. In this case, however, we won&#x27;t allow sending an <code>author</code> attribute as that&#x27;s something we might want to keep immutable from creation time. So in the most pure Praxis style, here&#x27;s how the payload would be designed:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  payload reference: MediaTypes::Post do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    attribute :title</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    attribute :content</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Copy that to the <code>update</code> action of the <code>Post</code> endpoint (<code>design/v1/endpoints/posts.rb</code>). Now, let&#x27;s take a look at a couple of things in this definition.</p><p>The first thing to notice is that we didn&#x27;t define types for any of the attributes. What&#x27;s that all about? Well, the answer lies in the <code>reference: MediaTypes::Post</code> option passed to <code>payload</code>. When a payload is given a MediaType reference, any attributes will directly inherit all of their type and options from the attribute with the same name in the MediaType. In this case, <code>title</code> and <code>content</code> will both be defined as <code>String</code> as that&#x27;s the type they have in the reference <code>Post</code> MediaType. Good, saved some keystrokes in there.</p><p>Notice that this is already a benefit from following the INPUTS==OUTPUTS paradigm, as it provides you with terser and more readable code, and it can help avoid silly copy and paste mistakes. We can always define any extra payload attribute we want (including its type and options), even if it does not exist in the reference MediaType. In fact, it is also possible to also redefine the type and options of an attribute, even if it exists in the reference MediaType (that&#x27;s generally a bad practice, though, as it&#x27;s not intuitive to the client)</p><p>Another thing to notice from the definition is that none of the attributes are required. That is because this <code>update</code> action (through the <code>PATCH</code> HTTP verb) only changes the attributes that are passed in, and leaves the rest untouched. If you wanted an update-type action that can change a member of the collection fully, we recommend the best practice of creating another action using a <code>PUT</code> verb to the same member url, and call it something like <code>replace</code> to clearly denote that it will replace <em>all</em> values of the object, including resetting the ones that aren&#x27;t passed in.</p><p>So all in all, we only needed to add a couple of attributes to the payload. Good times. Also, feel free to fire up the doc browser (<code>bundle exec praxis docs browser</code>) to see how our design turned out, in a more visually appealing way. Let&#x27;s move to the implementation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="implementing-update"></a>Implementing Update<a class="hash-link" href="#implementing-update" title="Direct link to heading">#</a></h3><p>So let&#x27;s now focus our efforts on building the implementation of what we have just designed. In particular we need to be able to update a <code>Post</code> based on the incoming payload we have defined. The first question is: how much should this controller code do? Let&#x27;s turn to another important set of Praxis best practices.</p><p>An important suggestion from Praxis is to confine controller code to only deal with HTTP concepts and transformations (request and response params, payload, headers, HTTP codes and errors, and etc.), while specifically avoiding any business logic (application domain logic). There are many reasons for this but the most important ones have to do with separation of concerns, testability and business logic reuse.</p><p>So what Praxis proposes for the <code>update</code> action of our controller is to simply call an underlying business logic object to update a <code>Post</code>, commonly using the same action name (i.e., <code>update</code>) and pass all of the necessary parameters to it. Once that call to the underlying logic is done, then simply return the <code>204 No Content</code>. Done. Short. Clean. Our controller only deals with HTTP protocol adaptation, with some massaging of the incoming/outgoing structures to and from the business logic objects.</p><p>Ok, so what are these business logic objects then? Well, Praxis calls them &quot;Resources&quot; and are nothing more than pure Ruby classes. Resources are the associated objects that sit in between the Controllers and the Data access, which contain the important business logic of your app. In other words: at the top level Controllers simply deal with HTTP and data structure concerns; at the lowest level Models deal with retrieving and saving data from or to the DB. Resources are reusable components of business logic that sit in the middle and abstract the underlying related models (or other related resources).</p><p>Alright, so how does that look in the controller code then? Let&#x27;s take a look at the scaffolded code for the <code>update</code> action that our generator built for us:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def update(id:)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # A good pattern is to call the same name method on the corresponding resource,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # passing the incoming id and payload (or massaging it first)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    updated_resource = Resources::Post.update(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      id: id,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      payload: request.payload,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Praxis::Responses::NotFound.new unless updated_resource</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Praxis::Responses::NoContent.new</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>The first thing to notice is that the <code>id</code> parameter we defined in our design step is passed in as a keyword argument to the function. It is also accessible through <code>request.params.id</code> but it is cleaner and more self-documenting to be a required function argument.</p><p>Another thing to notice is that the scaffolded code performs no validation whatsoever on the <code>id</code> or the <code>payload</code> elements. That is because a powerful part of building your API design with Praxis is that it will all be automatically validated and coerced before it can even reach your controller method. In other words, if our controller method is executed we can be 100% sure that the <code>id</code> is an Integer, and any of the passed payload attributes are <code>Strings</code>, as we have defined them. If there is any discrepancy with types of parameter names, the framework would have detected it and already sent a validation error back to the client detailing exactly what didn&#x27;t match the API specification.</p><p>The body of the function also follows the best practices we talked about. It calls a class method on the resource of the same name and gives it the necessary information to perform the job. In this case, the <code>id</code> of the post, and the incoming payload structure. In addition, it also returns a <code>404 Not Found</code> if the update call yield no resource, but otherwise it will return a <code>204 No Content</code> to indicate success. Some APIs like to return a <code>200 OK</code> with the resulting body of the updated resource. While this is perfectly fine and valid, we suggest it is much cleaner (and computationally cheaper) to just signal success without returning any payload, and let the the client decide to read the latest copy of the object in a subsequent request if necessary. This way it can also clearly specify which of the fields (including nested resources) it wants to gather. If we had to return the updated object in an update call, we&#x27;d either have to choose what fields to return, or somehow accept a <code>fields</code> parameter to know what to render. All are perfectly acceptable options, it&#x27;s more a matter of preference.</p><p>Ok, so nothing for us to change here, that&#x27;s cool. So let&#x27;s now look at this <code>update</code> method of the resource, where the business logic lives:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def self.update(id:, payload:)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record = model.find_by(id: id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return nil unless record</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Assuming the API field names directly map the the model attributes. Massage if appropriate.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record.update(**payload.to_h)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.new(record)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Well, it doesn&#x27;t seem that we need to change anything here either! This scaffolded code is loading the model by <code>id</code> from the DB and returning <code>nil</code> to signal it didn&#x27;t find it if applicable. If found, it simply updates the model attributes with the received values and returns the updated record wrapped in a resource instance. Done. The simplicity of this method is due to the fact that the API attributes have the same name as the ORM model. If they were different, we would probably have to do some extra massaging before invoking the model&#x27;s update method .</p><p>So with that, we have finished the implementation for updating Posts. Let&#x27;s give it a go real quick, by first starting (or restarting) the web API (<code>bundle exec rackup</code>) and sending a PATCH request to change the title and content of <code>Post</code> with <code>id</code>=1:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function" style="color:rgb(130, 170, 255)">curl</span><span class="token plain"> -XPATCH </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;http://localhost:9292/posts/1&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -H </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;X-Api-Version: 1&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -H </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;Content-Type: application/json&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -d </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;{ &quot;title&quot;: &quot;Changed Title&quot;, &quot;content&quot;: &quot;New Content&quot;}&#x27;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>There you go! You can now update posts. Check it out by reading the updated post with something like:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function" style="color:rgb(130, 170, 255)">curl</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;http://localhost:9292/posts/1?api_version=1&#x27;</span><span class="token plain"> -G </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      --data-urlencode </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;fields=id,title,content&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Ok, so this implementation for update took a bit of writing and explanation about best practices and options, but really, the scaffolding code did a very good job as we only had to change the payload definition of our <code>update</code> action! Not bad. Let&#x27;s look at what happens when we implement <code>create</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="create"></a>Create<a class="hash-link" href="#create" title="Direct link to heading">#</a></h2><p>The <code>create</code> action has many similarities with the previous <code>update</code> action. In fact, it could be almost identical. However, we are going to spice it up (for demonstration purposes) by accepting not only a <code>title</code> and <code>content</code> for a new post, but also a reference to an existing <code>User</code> as the author. Let&#x27;s design the endpoint first.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="designing-create"></a>Designing Create<a class="hash-link" href="#designing-create" title="Direct link to heading">#</a></h3><p>The first thing to notice is the RESTful design choices that the scaffold generator did for us in the endpoint:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  action :create do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    description &#x27;Create a new Post&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    routing { post &#x27;&#x27; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    payload reference: MediaTypes::Post do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # List the attributes you accept from the one existing in the Post Mediatype</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # and/or fully define any other ones you allow at creation time</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # attribute :name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    response :created</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    response :bad_request</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>This specifies that creating a post is done through a <code>POST</code> verb to the collection url (<code>/posts</code>), and successful creation will return a <code>204 Created</code> response containing a Location header of the href for the created resource. Otherwise it will respond with a <code>400 Bad Request</code> if the request couldn&#x27;t be completed (with the included information as to why not).</p><p>If we&#x27;re good with this fairly standard RESTful practice, the only thing that this needs to be completed is to define what payload attributes we want to accept to create a <code>Post</code>.</p><p>If we follow the INPUTS==OUTPUT best practices, we want to accept a payload that has a <code>title</code>, a <code>contents</code> and an <code>author</code> (with this attribute also matching a subset of the original <code>User</code> MediaType). So, in the more pure Praxis style, here&#x27;s how the payload would be designed:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  payload reference: MediaTypes::Post do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    attribute :title</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    attribute :content</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    attribute :author do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      attribute :id, required: true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    requires.at_least(1).of :title, :content</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    requires.all :author</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Now, let&#x27;s take a look at a couple of things from this definition.</p><p>The first one, again, is that we didn&#x27;t define types for any of the attributes. There&#x27;s no need since the attribute structure and names match the referenced <code>Post</code> MediaType. Yay! Again a best practice that can reward you in terseness and avoid mistakes when you follow the INPUTS==OUTPUTS paradigm. Note that any extra payload attribute that we might want to accept can still be fully defined with its type and options.</p><p>The second thing to notice is how we&#x27;ve defined the way to specify the author of the post. Often times you see a payload having an <code>author_id</code> attribute, but following the INPUTS==OUTPUTS paradigm we want to change that to have an <code>author</code> struct, with only an <code>id</code> inside. In the same fashion, we can trivially start accepting other author information like <code>email</code> or <code>uuid</code> (even optionally within the <code>author</code> struct) to connect the <code>Post</code> to it. It&#x27;s all about the consistency and the principle of least surprise to your users of the API.</p><p>Finally (and more for demonstration purposes than anything else), we have decided that we can accept a post without a <code>title</code> or without a <code>content</code>, but we need at least one of them. The <code>author</code> however is always required (along with its <code>id</code>).</p><p>Let&#x27;s turn to the implementation now.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="implementing-create"></a>Implementing Create<a class="hash-link" href="#implementing-create" title="Direct link to heading">#</a></h3><p>This is the scaffolded code we find for <code>create</code> in the controller:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Creates a new Post</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def create</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # A good pattern is to call the same name method on the corresponding resource,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # passing the incoming payload, or massaging it first</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    created_resource = Resources::Post.create(request.payload)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Respond with a created if it successfully finished</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Praxis::Responses::Created.new(location: created_resource.href)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Umm... well, that looks good enough, doesn&#x27;t it? Seems we&#x27;re done with our controller! Let&#x27;s build the actual business logic, shall we?</p><p>To do so, let&#x27;s turn to our scaffolded <code>Post</code> resource in <code>app/v1/resources/post.rb</code>. As you can see, for now there is no extra logic other than actually creating a row in the DB and returning an instance of the resource that wraps it:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def self.create(payload)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Assuming the API field names directly map the the model attributes. Massage if appropriate.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.new(model.create(**payload.to_h))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>This scaffolded code assumes that the payload attributes of the API have the same name as the model attributes. Obviously, with our inclusion of a linked <code>author</code> id, this is not 100% correct. So in this case, we do need to change the scaffolded implementation to account for that. Not much, though, as we just need to change it to this:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def self.create(payload)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    author = ::User.find_by(id: payload.author.id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    raise &quot;Author with id #{payload.author.id} not found&quot; unless author</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    data = payload.to_h</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    data[:author] = author</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.new(model.create(**data))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Let&#x27;s look at what we&#x27;ve done. First we dig the <code>author.id</code> from the payload and look the <code>User</code> in the DB, by <code>id</code>. Note that we do not need to check if the <code>author</code> or the <code>id</code> are null as that&#x27;s all taken care for us by the framework.</p><p>If we cannot find this user we need to signal something back to the client. In this trivial example we&#x27;re just raising a string, but typically you&#x27;d have this code raise some well known error class and make the controller catch it and respond appropriately with the right HTTP response. For example, create a <code>ResourceNotFoundError</code> class or similar, and use it to signal this business logic case (remember this code is not aware of any HTTP concerns, just application business logic). We&#x27;ll leave this as an exercise to the reader ;).</p><p>If we have found the user, we simply create a ruby hash from the payload and substitute the <code>:author</code> attribute with the appropriate user model. ActiveRecord, in this case, knows how to properly fill in the foreign keys since the <code>Post</code> model has an <code>:author</code> association defined pointing to the <code>User</code> model. We could have passed the <code>:author_id</code> field just as well.</p><p>And that&#x27;s it. In this case we couldn&#x27;t simply use the scaffolded code because we wanted to showcase accepting an <code>author</code> field on create, but it was fairly easy and short to adapt for it.</p><p>Now, let&#x27;s restart our API server and create a <code>Post</code>. To do that, we will send a POST request, with a body containing the <code>title</code> and an <code>author</code> sub-hash containing an <code>id</code>. The following curl request creates a post titled <code>New Title</code>, linked to author with <code>id</code>=11:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function" style="color:rgb(130, 170, 255)">curl</span><span class="token plain"> -XPOST </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;http://localhost:9292/posts&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -D - </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -H </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;X-Api-Version: 1&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -H </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;Content-Type: application/json&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -d </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;{ &quot;title&quot;: &quot;New Title&quot;, &quot;author&quot;: { &quot;id&quot;: 11}}&#x27;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Note that we&#x27;ve added the &quot;-D -&quot; flag to curl to ask it to print the response headers. This way we can confirm that we properly get a <code>Location</code> header which tells us the URL (and therefore id) of the newly created post. Boom! it works!</p><p>And finally, let&#x27;s wrap up our CRUD tutorial by looking at the <code>delete</code> action.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="delete"></a>Delete<a class="hash-link" href="#delete" title="Direct link to heading">#</a></h2><p>The delete action is definitely the easiest one, let&#x27;s design it first.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="designing-delete"></a>Designing Delete<a class="hash-link" href="#designing-delete" title="Direct link to heading">#</a></h3><p>From a design perspective, a delete is very similar to the <code>update</code>, except that it does not need any payload information, it only needs the <code>id</code> of the post to delete. Here&#x27;s the scaffolded endpoint for delete:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  action :delete do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    description &#x27;Deletes a Post&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    routing { delete &#x27;/:id&#x27; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    params do</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      attribute :id, required: true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    response :no_content</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    response :not_found</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>It all looks exactly how we want it. This defines that a delete is done through a <code>DELETE</code> verb to the member url of the posts collection (<code>/posts/:id</code>), where <code>:id</code> is the given identifier of the post. As a response, the client must expect a <code>204 No Content</code> when successful update, or a <code>400 Bad Request</code> when the request couldn&#x27;t be completed (with included information as to why not).</p><p>Ok then, nothing to be added...moving along to the implementation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="implementing-delete"></a>Implementing Delete<a class="hash-link" href="#implementing-delete" title="Direct link to heading">#</a></h3><p>Looking at the scaffolded Controller implementation for delete also reveals a structure almost identical to <code>update</code>:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def delete(id:)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # A good pattern is to call the same name method on the corresponding resource,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # maybe passing the already loaded model</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    deleted_resource = Resources::Post.delete(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      id: id</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Praxis::Responses::NotFound.new unless deleted_resource</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Praxis::Responses::NoContent.new</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>In fact, it is exactly the same code but calling the <code>delete</code> method of the resource, which obviously does not need a payload. Good, nothing to do here either. How about the <code>delete</code> method where the business logic lives?</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-ruby codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  def self.delete(id:)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record = model.find_by(id: id)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return nil unless record</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    record.destroy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.new(record)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Well, nothing to be done here either as it simply loads and destroys the model, or returns nil if it couldn&#x27;t find it. Nice job scaffolder!</p><p>Wanna delete a post? Yeah, I thought so. Create one with the previous curl above, and use the resulting id to delete it (buy substituting the <code>YOUR_ID_HERE</code> in the curl below for your id):</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function" style="color:rgb(130, 170, 255)">curl</span><span class="token plain"> -XDELETE </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;http://localhost:9292/posts/YOUR_ID_HERE&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">\</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    -H </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;X-Api-Version: 1&#x27;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="summary"></a>Summary<a class="hash-link" href="#summary" title="Direct link to heading">#</a></h1><p>So...just like that, we have built a full-on CRUD API for Posts, by literally just pasting a few lines of code (mostly just to define our own media type structures and payload attributes, as well as the <code>create</code> method of the resource due to our special-cased linked user). Hopefully you enjoyed it and have started to see that while this was just the tip of the iceberg, Praxis makes it easy and efficient to build powerful, consistent and fully documented APIs, all with extreme developer productivity.</p></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/gettingStarted/implementingReads"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Implementing Reads</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/reference/intro"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Introduction Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#update" class="table-of-contents__link">Update</a><ul><li><a href="#designing-update" class="table-of-contents__link">Designing Update</a></li><li><a href="#implementing-update" class="table-of-contents__link">Implementing Update</a></li></ul></li><li><a href="#create" class="table-of-contents__link">Create</a><ul><li><a href="#designing-create" class="table-of-contents__link">Designing Create</a></li><li><a href="#implementing-create" class="table-of-contents__link">Implementing Create</a></li></ul></li><li><a href="#delete" class="table-of-contents__link">Delete</a><ul><li><a href="#designing-delete" class="table-of-contents__link">Designing Delete</a></li><li><a href="#implementing-delete" class="table-of-contents__link">Implementing Delete</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog/">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.27a80096.js"></script>
<script src="/runtime~main.d759ace7.js"></script>
<script src="/main.0f7e767c.js"></script>
<script src="/1.1d955ac3.js"></script>
<script src="/65.fc2dba12.js"></script>
<script src="/66.81df1f16.js"></script>
<script src="/935f2afb.f1e5e5bf.js"></script>
<script src="/64.4c9a6482.js"></script>
<script src="/c498de60.b6b7fd24.js"></script>
</body>
</html>