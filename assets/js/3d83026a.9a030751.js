"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[8302],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=o,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||r;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3784:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={title:"Controllers"},i=void 0,s={unversionedId:"reference/implementation/controllers",id:"reference/implementation/controllers",title:"Controllers",description:"Controllers are the entrypoint where the implementation to fulfill all API requests live.",source:"@site/docs/reference/implementation/controllers.md",sourceDirName:"reference/implementation",slug:"/reference/implementation/controllers",permalink:"/docs/reference/implementation/controllers",draft:!1,tags:[],version:"current",frontMatter:{title:"Controllers"},sidebar:"mainSidebar",previous:{title:"Multipart",permalink:"/docs/reference/design/multipart"},next:{title:"Resources",permalink:"/docs/reference/implementation/resources"}},l={},p=[{value:"Including the Controller concern",id:"including-the-controller-concern",level:2},{value:"Linking to the Endpoint Definition",id:"linking-to-the-endpoint-definition",level:2},{value:"Implementing an Action",id:"implementing-an-action",level:2},{value:"Retrieving Headers and Payload Data",id:"retrieving-headers-and-payload-data",level:2},{value:"Nil vs not-provided values",id:"nil-vs-not-provided-values",level:2},{value:"Returning a Response",id:"returning-a-response",level:2},{value:"Default response object",id:"default-response-object",level:3},{value:"Strings as responses",id:"strings-as-responses",level:3},{value:"Request Life Cycle Callbacks",id:"request-life-cycle-callbacks",level:2}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Controllers are the entrypoint where the implementation to fulfill all API requests live.\nThey behave much in the same as they do in other MVC-based web frameworks - they implement the actions that receive requests from API clients, operate on the underlying resources to service those requests, and return the\nappropriate responses. In short, controllers are the glue which connects actions and their responses to application business logic."),(0,o.kt)("p",null,"Praxis controllers differ from some other frameworks in that they:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"are plain Ruby classes that happen to include the ",(0,o.kt)("inlineCode",{parentName:"li"},"Praxis::Controller")," module. By using plain Ruby classes, Praxis allows you to use the full power of Ruby. You are not limited in your inheritance options, and your controller code can be well-isolated and easily tested."),(0,o.kt)("li",{parentName:"ul"},"serve actions by implementing an instance method with the same name as the action in your endpoint, which accept Ruby ",(0,o.kt)("strong",{parentName:"li"},"keyword")," parameters corresponding to the attribute names of the action definition. Exposing the common parameters as keword method arguments, make your code and interface cleaner, and connects to the API definition in a more direct way.")),(0,o.kt)("h2",{id:"including-the-controller-concern"},"Including the Controller concern"),(0,o.kt)("p",null,"To implement a controller in Praxis, include the ",(0,o.kt)("inlineCode",{parentName:"p"},"Praxis::Controller")," module in your controller class and indicate which of your Resource Definitions it implements by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"implements")," stanza. For example, this could be how you create rthe Post controller class, which will serve the implementation of all actions defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"Endpoints::Posts"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"class Posts\n  include Praxis::Controller\n\n  implements Endpoints::Posts\n\n  # Controller code...\nend\n")),(0,o.kt)("p",null,"Including the ",(0,o.kt)("inlineCode",{parentName:"p"},"Praxis::Controller")," module enhances the class with important methods such as ",(0,o.kt)("inlineCode",{parentName:"p"},"implements"),", lifecycle methods (i.e.,",(0,o.kt)("inlineCode",{parentName:"p"},"before"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"around")," ",(0,o.kt)("inlineCode",{parentName:"p"},"after"),"), ",(0,o.kt)("inlineCode",{parentName:"p"},"request")," to retrieve the incoming API request object, and ",(0,o.kt)("inlineCode",{parentName:"p"},"response")," for using the default response object when needed."),(0,o.kt)("h2",{id:"linking-to-the-endpoint-definition"},"Linking to the Endpoint Definition"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"implements"),' method is used to connect a controller with its corresponding EndpointDefinition. Technically speaking there is nothing that prevents having the Endpoint definition from also being a controller (i.e., implementing itself). However, and despite that being feasible due to the modularity that Praxis provides, we highly discourage it in order to keep "design" logically separate from "implementation".'),(0,o.kt)("p",null,"Once the controller is linked, you can also get to its corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"EndpointDefinition")," object through the ",(0,o.kt)("inlineCode",{parentName:"p"},"definition")," method, which is defined on both the class and instance."),(0,o.kt)("h2",{id:"implementing-an-action"},"Implementing an Action"),(0,o.kt)("p",null,"A controller action is an instance method defined on a controller class. The method's name must match an action defined in the controller's resource definition. And its keyword arguments must match the defined parameters in the action."),(0,o.kt)("p",null,"For example, on the design side, we can have an endpoint definition class for ",(0,o.kt)("inlineCode",{parentName:"p"},"Posts")," that defines two actions: ",(0,o.kt)("inlineCode",{parentName:"p"},":index")," and ",(0,o.kt)("inlineCode",{parentName:"p"},":show"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"class Endpoints::Posts\n  include Praxis::EndpointDefinition\n\n  media_type Post\n  version '1.0'\n\n  action :index do\n    routing { get '' }\n    description 'Fetch all blog posts'\n  end\n\n  action :show do\n    routing { get '/:id' }\n    description 'Fetch an individual blog post'\n    params do\n      attribute :id, Integer, required: true\n      attribute :token, String, required: true\n      attribute :allow_deleted, Attributor::Boolean\n      attribute :extended_info, Attributor::Boolean\n    end\n  end\nend\n")),(0,o.kt)("p",null,"The controller implementing this resource definition must have instance methods named ",(0,o.kt)("inlineCode",{parentName:"p"},"index")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"show")," must which accept the argument names described by the params block from the resource definition."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"class Posts\n  include Praxis::Controller\n\n  implements Endpoints::Posts\n\n  def index\n    # empty method signature: the index action defines no parameters\n  end\n\n  def show(id:, token:, **other_params)\n    # four parameters defined matching the names of the arguments\n    # Note that ruby allows is to unpack only the names we care about\n    # and leave the rest tucked away in the other_params hash\n  end\nend\n")),(0,o.kt)("p",null,"Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"index")," action has no parameters defined in its endpoint definition so the method accepts no arguments."),(0,o.kt)("p",null,"On the other hand, the ",(0,o.kt)("inlineCode",{parentName:"p"},"show")," action has four parameters defined in its endpoint, so it can explicitly declare them as named method arguments. Ruby gives you great flexibility in declaring named parameters with the splat operator. It is up to the developer to choose how many explicit arguments to list, and how many to tuck away inside an ",(0,o.kt)("inlineCode",{parentName:"p"},"other_params")," hash. In\nthis case, the developer decided that ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"token")," are important enough to use as direct variables in the controller (it is common to only explicitly list the required ones), while pushing the ",(0,o.kt)("inlineCode",{parentName:"p"},"allowed_deleted")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"extended_info")," into the other_params hash. Having this flexibility is great for dealing with large number of parameters while keeping your controller code tidy."),(0,o.kt)("p",null,"In addition to using named arguments for incoming parameters, Praxis will also ensure their values match the types that you've specified in the Endpoint Definition. So in this case, you can rest assured that accessing the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," variable within the ",(0,o.kt)("inlineCode",{parentName:"p"},"show")," method will always get you an Integer. In other words, there should be no type and parameter validation being done in your controller, because Praxis ensures that if the code makes it to your action, the parameters (and headers and payloads) will properly be there if they are required, and will have been successfully coerced to the defined types."),(0,o.kt)("h2",{id:"retrieving-headers-and-payload-data"},"Retrieving Headers and Payload Data"),(0,o.kt)("p",null,"While pure path and query string parameters are conveniently exposed as keyword arguments to the function. They are also accessible from inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"request")," method in the controller (which is provided by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Praxis::Controller")," include)."),(0,o.kt)("p",null,"In fact, you can not only get to the params structure by accessing ",(0,o.kt)("inlineCode",{parentName:"p"},"request.params"),", but you can also use the same technique to access the incoming API payload by ",(0,o.kt)("inlineCode",{parentName:"p"},"request.payload")," and the incoming headers by ",(0,o.kt)("inlineCode",{parentName:"p"},"request.headers"),". The data retrieved under these methods is type-curated exactly like keyword arguments and is accessible through calling method names matching your attributes. For example, I can access the same exact ",(0,o.kt)("inlineCode",{parentName:"p"},"token")," query string parameter by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"request.params.token"),", or retrieve a hypothetical ",(0,o.kt)("inlineCode",{parentName:"p"},"first_name")," parameter coming from the API payload of a request by ",(0,o.kt)("inlineCode",{parentName:"p"},"request.payload.first_name"),"."),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"request.headers")," will only give you the (coreced and validated) headers that you have defined. That is not the function to retrieve all the raw headers that the request carries. The rationale here is that if there are important headers that you're expecting to use in the action, you should probably have defined them in your API endpoint, as that's probably an important information for the API clients to know. For special circumstances, however, you can always access the raw Rack env (which contains the headers) by ",(0,o.kt)("inlineCode",{parentName:"p"},"request.env"),"."),(0,o.kt)("h2",{id:"nil-vs-not-provided-values"},"Nil vs not-provided values"),(0,o.kt)("p",null,"Using these Struct-type parameters, you can also test if an incoming value was provided by the client (or has been assigned by a ",(0,o.kt)("inlineCode",{parentName:"p"},"default")," option). To do so, just use the ",(0,o.kt)("inlineCode",{parentName:"p"},"key?")," method passing the attribute name. This is useful in those cases where there is an important distinction between a user-provided ",(0,o.kt)("inlineCode",{parentName:"p"},"nil"),' value and the user simply not providing a value, as there is in "PATCH" requests. '),(0,o.kt)("p",null,"Here's a simple made up example of how to access these methods from a controller action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"def update(id:,**other_params)\n  id == request.params.id             # id argument will be the same as request.params.id\n  accept = request.headers.accept     # Retrieve 'Accept' header\n\n  if request.payload.key?(:email)     # the email attribute was passed (which could be nil)\n    email = request.payload.email\n    email ? update_email(email) : reset_email   # Update or reset the email\n  else\n    # Leave email untouched    \n  end\nend\n")),(0,o.kt)("h2",{id:"returning-a-response"},"Returning a Response"),(0,o.kt)("p",null,"The final piece of every controller action ia to return a Response object with the right headers, status code and body. To do so, you literally ",(0,o.kt)("inlineCode",{parentName:"p"},"return")," an instance of a Praxis::Response-derived class from the action, and let Praxis worry about formatting and sending those bits back to the API client."),(0,o.kt)("p",null,"For every existing HTTP response code, Praxis has an appropriate Response class for you to use. They are all defined under the ",(0,o.kt)("inlineCode",{parentName:"p"},"Praxis::Responses")," module, using a camel-case named class based on their human http code message. For example, to return a ",(0,o.kt)("inlineCode",{parentName:"p"},"204 No Content")," HTTP response, you can simply create and return a ",(0,o.kt)("inlineCode",{parentName:"p"},"NoContent")," class instance in this way:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"}," return Praxis::Responses::NoContent.new\n")),(0,o.kt)("p",null,"These response classes also allow configuration as a way to pass the response payload and its headers. They can be configured on instantiation (by pasing arguments to the controller), or as method calls on the created instance."),(0,o.kt)("p",null,"Here's an example of how you can create a ",(0,o.kt)("inlineCode",{parentName:"p"},"201 Created")," response, with a ",(0,o.kt)("inlineCode",{parentName:"p"},"Location")," header of ",(0,o.kt)("inlineCode",{parentName:"p"},"/users/23"),", and a customer header of ",(0,o.kt)("inlineCode",{parentName:"p"},"X-My-Header")," with value ",(0,o.kt)("inlineCode",{parentName:"p"},"foo"),". This is done through setting things on the instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"response = Praxis::Responses::Created.new\nresponse.headers = {\n  'Location' => '/users/23',\n  'X-My-Header' => 'foo'\n}\nreturn response \n")),(0,o.kt)("p",null,"And this is the equivalent in doing it through instantiation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"}," return Praxis::Responses::Created.new(location: '/users/23', headers: {`X-My-Header` => `foo` })\n")),(0,o.kt)("p",null,"You are probably wondering why didn't we pass the location through a straight ",(0,o.kt)("inlineCode",{parentName:"p"},"Location")," header. The answer is that we could have, without problems. We just wanted to illustrate, that since it is so common, we've also allowed you to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"location:")," parameter to achieve the same. And, in fact, the same is true for a ",(0,o.kt)("inlineCode",{parentName:"p"},"media_type:")," parameter as well, which would be translated to the appropriate ",(0,o.kt)("inlineCode",{parentName:"p"},"Content-Type")," parameter of the passed in ",(0,o.kt)("inlineCode",{parentName:"p"},"MediaType")," object."),(0,o.kt)("h3",{id:"default-response-object"},"Default response object"),(0,o.kt)("p",null,"Many of your API actions are likely return a ",(0,o.kt)("inlineCode",{parentName:"p"},"200 Ok"),", at least for the normal execution path. To make things easier keep your controller DRY, Praxis will alway have an instance of a ",(0,o.kt)("inlineCode",{parentName:"p"},"200 Ok")," response ready for you in your action. You can access it through the ",(0,o.kt)("inlineCode",{parentName:"p"},"response")," method, and you can easily change it by setting a different instance of a response at any point in time. Using the precreated response, you can keep your code DRY by not having to create a new one every time you return a 200. Note that this is just a convenience to avoid creating instances for all of the common cases, but in fact, you don't even have to use that response instance at all if you don't want to, as you can always return any response you create from your action."),(0,o.kt)("p",null,"Here's an example of one way to use and return the default response:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},"def show(id:, **other_params)\n  response.headers['Content-Type'] = 'text/plain'\n  response.body = \"This is a simple body\"\n  response\nend\n")),(0,o.kt)("h3",{id:"strings-as-responses"},"Strings as responses"),(0,o.kt)("p",null,"While returning a Response instance from your action is the normal flow, there is also another way. In particular, you can instead return a simple string, and if you do so, Praxis take it as the body to send back to the client, and will make use of the current contents of the ",(0,o.kt)("inlineCode",{parentName:"p"},"response")," method to complete it. In other words, a string return will tell Praxis that you want to use the current contents of the ",(0,o.kt)("inlineCode",{parentName:"p"},"response")," object, with the passed string as the body. The ",(0,o.kt)("inlineCode",{parentName:"p"},"response")," method could be the default ",(0,o.kt)("inlineCode",{parentName:"p"},"200")," instance set by Praxis itself, or could be that you have set it to something else. The final result will set the body of that request to the string returned, and sent that request back to the client. Here's a typical example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'def show(id:, token:, **other_params)\n  response.headers[\'Content-Type\'] = \'application/json\'\n  \'{ "first_name" : "Joe", "email" : "joe@example.com" }\'\nend\n')),(0,o.kt)("p",null,"...which essentially results in 1) ",(0,o.kt)("inlineCode",{parentName:"p"},"response.body = <STR>")," and return ",(0,o.kt)("inlineCode",{parentName:"p"},"response")),(0,o.kt)("p",null,"Any returned value from an action that it is not a Response instance or a String is an immediate error."),(0,o.kt)("h2",{id:"request-life-cycle-callbacks"},"Request Life Cycle Callbacks"),(0,o.kt)("p",null,"Including the ",(0,o.kt)("inlineCode",{parentName:"p"},"Praxis::Controller")," module also provides a way to register one or more callbacks to be executed during the request life cycle. This is done using the ",(0,o.kt)("inlineCode",{parentName:"p"},"before"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"after")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"around")," methods which take zero or more params and a block for Praxis to execute."),(0,o.kt)("p",null,"For example, to execute a callback before the ",(0,o.kt)("inlineCode",{parentName:"p"},"show")," action runs, you can add:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'before actions: [:show] do\n  puts "before action"\nend\n')),(0,o.kt)("p",null,"To execute a callback before the ",(0,o.kt)("inlineCode",{parentName:"p"},"validate")," stage of the request cycle, but\nonly when the action is ",(0,o.kt)("inlineCode",{parentName:"p"},"index"),", you could add:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ruby"},'before :validate, actions: [:index] do |controller|\n  puts "About to validate params/headers/payload for action:"\n  puts "#{controller.request.action.name}"\nend\n')),(0,o.kt)("p",null,"The block receives the instance of your controller, which you can use to access\nall of the controller's properties, including the request, the response, any\nactions, etc."),(0,o.kt)("p",null,"Any of these callbacks are able to interrupt (i.e., shortcut) the execution block of a request by returning an Response instance. For a complete discussion of what stages are available for use in your callbacks, as well as how to use them, please refer to the ",(0,o.kt)("a",{parentName:"p",href:"request-life-cycle"},"Request LifeCycle")," documentation."))}u.isMDXComponent=!0}}]);