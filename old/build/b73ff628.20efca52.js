(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{112:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return s}));var r=n(3),i=n(7),a=(n(0),n(133)),o={title:"Application"},l={unversionedId:"reference/implementation/application",id:"reference/implementation/application",isDocsHomePage:!1,title:"Application",description:"Praxis allows certain application-wide level configuration and customization options.",source:"@site/docs/reference/implementation/application.md",slug:"/reference/implementation/application",permalink:"/docs/reference/implementation/application",version:"current",sidebar:"mainSidebar",previous:{title:"Controllers",permalink:"/docs/reference/implementation/controllers"},next:{title:"Responses",permalink:"/docs/reference/implementation/responses"}},c=[{value:"Uncaught Exceptions",id:"uncaught-exceptions",children:[]},{value:"Formatting Validation Responses",id:"formatting-validation-responses",children:[]},{value:"Rack Middleware",id:"rack-middleware",children:[]}],p={toc:c};function s(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Praxis allows certain application-wide level configuration and customization options."),Object(a.b)("h3",{id:"uncaught-exceptions"},"Uncaught Exceptions"),Object(a.b)("p",null,"Praxis allows you to register an error handler to define how to properly catch and act against uncaught exceptions in your code. By default, the default error handler of Praxis will simply print the exception and backtrace onto the configured ",Object(a.b)("inlineCode",{parentName:"p"},"Application.instance.logger")," and then immediately return an ",Object(a.b)("inlineCode",{parentName:"p"},"InternalServerError"),' response which will either contain the exception details in the body (Application.instance.config.praxis.show_exceptions == true) or simply "Something bad happe\ned" otherwise.'),Object(a.b)("p",null,"You can register your own error handler class by setting it with ",Object(a.b)("inlineCode",{parentName:"p"},"Application#error_handler"),". For example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ruby"}),"Praxis::Application.configure do |application|\n  application.error_handler = MyErrorHandler.new\nend\n")),Object(a.b)("p",null,"The error handler class must implement a ",Object(a.b)("inlineCode",{parentName:"p"},"handle!(request, error)")," method, where ",Object(a.b)("inlineCode",{parentName:"p"},"request")," is the current ",Object(a.b)("inlineCode",{parentName:"p"},"Request")," instance being processed, and ",Object(a.b)("inlineCode",{parentName:"p"},"error")," is the exception in question. The return value must be a low-level Rack response tuple (i.e., ",Object(a.b)("inlineCode",{parentName:"p"},"[status,headers,body]")," ), which will be immediatly sent back to the client."),Object(a.b)("h3",{id:"formatting-validation-responses"},"Formatting Validation Responses"),Object(a.b)("p",null,"Any validation errors encountered in the flow of the request will be processed by the registered ",Object(a.b)("inlineCode",{parentName:"p"},"validation_handler")," in the Application. By default, Praxis validation_handler will simply return a response of type ",Object(a.b)("inlineCode",{parentName:"p"},"Responses::ValidationError"),"."),Object(a.b)("p",null,"This default behavior, however, may be customized by registering your own validation handler like this:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ruby"}),"Praxis::Application.configure do |application|\n  application.validation_handler = MyValidationHandler.new\nend\n")),Object(a.b)("p",null,"The validation handler must implement a ",Object(a.b)("inlineCode",{parentName:"p"},"handle!(summary:, request:, stage:, errors: nil, exception: nil, **opts)")," method where:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"summary")," is a string containing a short description of the validation error that has just occurred"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"request")," is the current ",Object(a.b)("inlineCode",{parentName:"li"},"Request")," instance being processed. One can get to the ",Object(a.b)("inlineCode",{parentName:"li"},"action")," and other interesting values from it."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"stage")," is a symbol denoting where in the request flow the validation error occurred. The possible received values are:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},":params_and_headers"),": if it occurred validating the parameters or headers."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},":payload"),": if it occurred validating the payload."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},":response"),": if it occurred validating the response. This can only occur if the ",Object(a.b)("inlineCode",{parentName:"li"},"validate_responses")," configuration is enabled."))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"errors")," is an array of the errors as returned by the underlying type validations performed. The default types for headers, params and payload will return individual error message containing a string with the details of the encountered error. If you are using custom payload types, however, they could return different data in each of the individual error messages."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"exception")," is the exception in question.")),Object(a.b)("p",null,"The return valid from the ",Object(a.b)("inlineCode",{parentName:"p"},"handle!")," must be a Praxis response, which will be directly returned to the client."),Object(a.b)("h3",{id:"rack-middleware"},"Rack Middleware"),Object(a.b)("p",null,"Praxis allows you to programatically register Rack middleware with the application. The syntax is analogous to the ",Object(a.b)("inlineCode",{parentName:"p"},"use")," directive in ",Object(a.b)("inlineCode",{parentName:"p"},"Rack::Builder")," works. Doing that through Praxis vs mounting the middleware at the lowest with Rack is basically a matter of choice. Sometimes its cleaner to register middleware in your ",Object(a.b)("inlineCode",{parentName:"p"},"config.ru")," file that is completely detached from the actual API, and sometimes is good to embed certain middleware configurations as part of configuring your Praxis Application after certain pieces of code have been properly loaded."),Object(a.b)("p",null,"A typical way to register your middleware through praxis is by adding the following snippet in ",Object(a.b)("inlineCode",{parentName:"p"},"config/environment.rb"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ruby"}),"Praxis::Application.configure do |application|\n  application.middleware MyMiddleware\nend\n")))}s.isMDXComponent=!0},133:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var r=n(0),i=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=i.a.createContext({}),s=function(e){var t=i.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return i.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=s(n),b=r,m=d["".concat(o,".").concat(b)]||d[b]||u[b]||a;return n?i.a.createElement(m,l(l({ref:t},p),{},{components:n})):i.a.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=b;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<a;p++)o[p]=n[p];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);