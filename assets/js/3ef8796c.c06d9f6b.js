"use strict";(self.webpackChunkpraxis_site=self.webpackChunkpraxis_site||[]).push([[6131],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||s;return n?o.createElement(f,a(a({ref:t},c),{},{components:n})):o.createElement(f,a({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,a=new Array(s);a[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:r,a[1]=i;for(var p=2;p<s;p++)a[p]=n[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},328:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var o=n(7462),r=(n(7294),n(3905));const s={title:"Responses"},a=void 0,i={unversionedId:"reference/implementation/responses",id:"reference/implementation/responses",title:"Responses",description:"The main goal for an API service is to return the right HTTP responses to the client. There are many different types API response, with many different HTTP codes, different types of payload encodings, headers...etc.",source:"@site/docs/reference/implementation/responses.md",sourceDirName:"reference/implementation",slug:"/reference/implementation/responses",permalink:"/docs/reference/implementation/responses",draft:!1,tags:[],version:"current",frontMatter:{title:"Responses"},sidebar:"mainSidebar",previous:{title:"Application",permalink:"/docs/reference/implementation/application"},next:{title:"Request Life Cycle",permalink:"/docs/reference/implementation/request-life-cycle"}},l={},p=[{value:"Response Body",id:"response-body",level:2},{value:"Creating Custom Response Classes",id:"creating-custom-response-classes",level:2},{value:"Multipart Responses",id:"multipart-responses",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The main goal for an API service is to return the right HTTP responses to the client. There are many different types API response, with many different HTTP codes, different types of payload encodings, headers...etc."),(0,r.kt)("p",null,"Praxis makes some of this easier by providing a response class for every existing HTTP response code. These classes are all defined within the ",(0,r.kt)("inlineCode",{parentName:"p"},"Praxis::Responses")," module, and they are named based on their human http code message. For example, you can find the ",(0,r.kt)("inlineCode",{parentName:"p"},"Praxis::Responses::NoContent")," to refer to a ",(0,r.kt)("inlineCode",{parentName:"p"},"204 No Content")," HTTP response. See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/praxis/praxis/blob/master/lib/praxis/responses/http.rb"},"this")," file for their definition."),(0,r.kt)("p",null,"Here's an example of how to create a simple 204 response and save it in a ",(0,r.kt)("inlineCode",{parentName:"p"},"resp")," variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"}," resp = Praxis::Responses::NoContent.new\n")),(0,r.kt)("p",null,"These instances of response object expose several different way to configure and manage pieces of their structure."),(0,r.kt)("h2",{id:"response-body"},"Response Body"),(0,r.kt)("p",null,"Many responses have a body: some useful content that is sent back to the user agent. You can easily set the body for a response by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"body=")," writer of your instance. If your response has a body, then you should also set its ",(0,r.kt)("inlineCode",{parentName:"p"},"content_type=")," so the user agent will know how to handle your data."),(0,r.kt)("p",null,"If you provide a String when setting the body body, Praxis will respond verbatim with the body and content-type header you have provided. If you provide structured data -- a Hash or an Array -- Praxis will analyze your response's ",(0,r.kt)("inlineCode",{parentName:"p"},"content_type")," and encode your data using a suitable handler (and default to JSON if no specific handler seems appropriate).\nSee ",(0,r.kt)("a",{parentName:"p",href:"../internals/handlers/"},"Handlers")," to learn how to customize encoding."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"response.content_type = 'application/vnd.acme.greeting'\nresponse.body = {hi: 'mom'}\n\n# The user agent will receive a response like so:\n#   Content-Type: application/vnd.acme.greeting+json\n#\n#   {\"hi\":\"mom\"}\n")),(0,r.kt)("p",null,"Response encoding is performed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"encode!")," method of the Response base class;\ncustom responses may alter or supplant this behavior."),(0,r.kt)("h2",{id:"creating-custom-response-classes"},"Creating Custom Response Classes"),(0,r.kt)("p",null,"While Praxis provides a Response class for all well known response codes, you can still decide to create or customize one for your purposes. To do so, this is what you need to do:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"create a class that extends ",(0,r.kt)("inlineCode",{parentName:"li"},"Praxis::Response")),(0,r.kt)("li",{parentName:"ul"},"set the response name. This links your class to a response definition, the\nAPI design object."),(0,r.kt)("li",{parentName:"ul"},"optionally set the class-level ",(0,r.kt)("inlineCode",{parentName:"li"},"status")," value. If you don't do it here, you\nwill need to set it in an initializer")),(0,r.kt)("p",null,"Your new response class may then define/override the following methods, which will be invoked before sending the request to the client:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"handle"),": executes any business logic that needs to be done to complete the response data."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"format!"),": constructs the format of the response object. For example, it could transform the body object into a hash with appropriate attributes. The default ",(0,r.kt)("inlineCode",{parentName:"li"},"format!")," behavior is to not modify the body."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"encode!"),": encodes the formatted contents of the request. For example, it could look at some aspect of the request to figure out how to encode the response into JSON or something else.")),(0,r.kt)("p",null,"Here is an example of a custom response class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"# As specified in RFC 2324 (seriously; look it up!)\nclass ImATeapot < Praxis::Response\n  self.response_name = :tea_pot\n  self.status = 418\n\n  def handle\n    # custom logic  (or nothing if the initialization defaults are enough)\n    headers['X-TeaPot'] = 'MadeInJapan'\n  end\nend\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note:")," Each of the response classes you create in the runtime part of your application will need a corresponding response template defined in the design area that shares the same name. Make sure you use the ",(0,r.kt)("inlineCode",{parentName:"p"},"register_response")," DSL that the ApiDefinition class provides. In this case, we would need to register a template named ",(0,r.kt)("inlineCode",{parentName:"p"},":tea_pot"),", which must match a status code of 418 and a 'X-TeaPot' header of value 'MadeInJapan'. See ",(0,r.kt)("a",{parentName:"p",href:"../design/response-definitions"},"Response Definitions")," for more information on how to do that. If you don't register a template for each of your classes, you will not be able to refer to them in your ",(0,r.kt)("inlineCode",{parentName:"p"},"response")," stanzas of your actions in your EndpointDefinitions."),(0,r.kt)("h2",{id:"multipart-responses"},"Multipart Responses"),(0,r.kt)("p",null,"Praxis also provides support for generating multipart responses. Please see ",(0,r.kt)("a",{parentName:"p",href:"multipart"},"Multipart Responses")," for how to do so."))}u.isMDXComponent=!0}}]);