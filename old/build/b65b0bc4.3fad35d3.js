(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var i=n(3),a=n(7),r=(n(0),n(133)),o={title:"Media Types"},s={unversionedId:"reference/design/media-types",id:"reference/design/media-types",isDocsHomePage:!1,title:"Media Types",description:"Media types provide the structural representation of the API resources we want to expose. They also commonly have an associated name (i.e., its identifier).",source:"@site/docs/reference/design/media-types.md",slug:"/reference/design/media-types",permalink:"/docs/reference/design/media-types",version:"current",sidebar:"mainSidebar",previous:{title:"Introduction",permalink:"/docs/reference/intro"},next:{title:"Endpoints",permalink:"/docs/reference/design/endpoints"}},l=[{value:"Description",id:"description",children:[]},{value:"Identifier",id:"identifier",children:[]},{value:"Attributes",id:"attributes",children:[]},{value:"Default fielset",id:"default-fielset",children:[]},{value:"Collections",id:"collections",children:[{value:"Praxis::Collection",id:"praxiscollection",children:[]},{value:"Attributor::Collection",id:"attributorcollection",children:[]}]},{value:"Rendering mediatypes",id:"rendering-mediatypes",children:[]},{value:"Examples",id:"examples",children:[]}],c={toc:l};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Media types provide the structural representation of the API resources we want to expose. They also commonly have an associated name (i.e., its identifier). "),Object(r.b)("p",null,"How does that work? Let's take a look at an example. Let's say we want to expose Users in our API. In this case, our users MediaType could be defined by a structure that contains an ",Object(r.b)("inlineCode",{parentName:"p"},"id"),", ",Object(r.b)("inlineCode",{parentName:"p"},"name")," and ",Object(r.b)("inlineCode",{parentName:"p"},"email"),", and be represented by the following identifier ",Object(r.b)("inlineCode",{parentName:"p"},"application/vnd.mycompany.users"),". So in this case, if a client issues an API to retrieve a user, he will receive a response with ",Object(r.b)("inlineCode",{parentName:"p"},"Content-Type: application/vnd.mycompany.users+json"),", which indicates 2 different things: The first one is to indicat what type of attribute ",Object(r.b)("strong",{parentName:"p"},"shape")," the payload contains (i.e., ",Object(r.b)("inlineCode",{parentName:"p"},"id"),", ",Object(r.b)("inlineCode",{parentName:"p"},"name")," and ",Object(r.b)("inlineCode",{parentName:"p"},"email")," fields). The second one (denoted by the ",Object(r.b)("inlineCode",{parentName:"p"},"+json")," suffix) indicates that the returned structure is encoded using JSON. "),Object(r.b)("p",null,"Praxis Media-Types are concerned only with the design aspects only (i.e., structure and name), and leaves any encoding concerns to the implementation part. So it is worth noting that a MediaType definition does imply any particular encoding (JSON vs XML...). "),Object(r.b)("p",null,"So, how do we define these in Praxis? To define a media type for an API resource, we simply create a class that derives from ",Object(r.b)("inlineCode",{parentName:"p"},"Praxis::MediaType"),", where we can define its structure within the ",Object(r.b)("inlineCode",{parentName:"p"},"attributes")," section and give it a unique identifier name. A media type can also have a human-readable description, which will show up in any generated documentation."),Object(r.b)("p",null,"Here's an example of a simple media type that describes a few attributes for a\nhypothetical Blog API resource."),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Blog < Praxis::MediaType\n  description 'A Blog API resource represents...'\n  identifier 'application/vnd.acme.blog'\n\n  attributes do\n    attribute :id, Integer\n    attribute :href, String\n    attribute :owner, Person\n    attribute :subject, String\n    attribute :locale do\n      attribute :language, String\n      attribute :country, String\n    end\n  end\nend\n")),Object(r.b)("h2",{id:"description"},"Description"),Object(r.b)("p",null,"You can specify a description for the media type using the ",Object(r.b)("inlineCode",{parentName:"p"},"description"),"\nmethod. This description string is just for human consumption and is simply inserted directly into to the generated API documentation."),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Blog < Praxis::MediaType\n  description <<-eos\n    This is a sample blog.\n    Which requires a much longer an elaborate description to be written.\n  eos\nend\n")),Object(r.b)("h2",{id:"identifier"},"Identifier"),Object(r.b)("p",null,"The media type identifier method allows you to associate an Internet media type\nstring with the MediaType definition. Internet media types should typically be used as unique names (i.e., 'application/vnd.acme.blog') that way the client receiving the response knows exactly what structure to expect to find. However, it is not necessary to do so, and they can be also be left withot a name by using just an encoder string (i.e., 'application/json')."),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Blog < Praxis::MediaType\n  identifier 'application/vnd.acme.blog'\nend\n")),Object(r.b)("p",null,"Identifiers have an optional suffix that indicates the encoding format used to represent the media;\nfor instance, a blog could be represented as an ",Object(r.b)("inlineCode",{parentName:"p"},"application/vnd.acme.blog+json")," or a ",Object(r.b)("inlineCode",{parentName:"p"},"+xml"),"\nwithout changing its essential blog-ness. Identifiers can also have semicolon-delimited options\nsuch as ",Object(r.b)("inlineCode",{parentName:"p"},"text/html; charset=utf-8"),".."),Object(r.b)("p",null,"In Praxis, media type identifiers are represented by the ",Object(r.b)("inlineCode",{parentName:"p"},"MediaTypeIdentifier")," class which parses\nthe identifier's components and makes them available as instance accessors: ",Object(r.b)("inlineCode",{parentName:"p"},"type"),", ",Object(r.b)("inlineCode",{parentName:"p"},"subtype"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"suffix")," and ",Object(r.b)("inlineCode",{parentName:"p"},"parameters"),". Identifier objects can be compared, modified, fuzzy-matched against\nbroader or narrower types, and transformed back into strings."),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"MediaTypeIdentifier.load('text/plain; charset=utf-8').parameters['charset'] # => \"utf-8\"\nMediaTypeIdentifier.load('image/*').match('image/jpeg') # => true\n")),Object(r.b)("h2",{id:"attributes"},"Attributes"),Object(r.b)("p",null,"The attributes section of the media type describes the full structure of the\nresource representation. It describes the superset of all possible attributes\nthat can appear in any view that can be rendered."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"attributes")," method expects a block of attribute definitions:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Blog < Praxis::MediaType\n  attributes do\n    attribute :id, Integer\n    attribute :href, String,        regexp: %r{/blogs/\\d+}\n    attribute :owner, Person,       description: 'Owner of this Blog'\n    attribute :subject, String\n    attribute :created_at, DateTime\n    attribute :visibility, String,  values: ['public','private']\n  end\nend\n")),Object(r.b)("p",null,"Each attribute has a name, type, description and other specific configuration\noptions: allowed values, format, examples, etc. While some options, such as\n",Object(r.b)("inlineCode",{parentName:"p"},"description")," and ",Object(r.b)("inlineCode",{parentName:"p"},"values")," are always available for any attribute, different\nattribute types support type-specific options: ",Object(r.b)("inlineCode",{parentName:"p"},"min"),"/",Object(r.b)("inlineCode",{parentName:"p"},"max")," values for Integers,\n",Object(r.b)("inlineCode",{parentName:"p"},"regexp")," for Strings, etc. "),Object(r.b)("p",null,"Similarly to the overall MediaType description, the documentation browser will render attribute ",Object(r.b)("inlineCode",{parentName:"p"},"description")," values in the generated docs."),Object(r.b)("p",null,"To read more about supported types and defining a complex and rich structures,\ntake a look at the ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://rubygems.org/gems/attributor"}),"Attributor")," gem and\nother Praxis media type examples."),Object(r.b)("h2",{id:"default-fielset"},"Default fielset"),Object(r.b)("p",null,"One way to think of media types is that they contain the superset of attributes that can ever be returned. Often times, we might want to return only some of those when rendering responses. In fact, we will see in the rendering extensions sections that we can allow the API client to fully specify which subset of the available attributes to return, depending on what it needs."),Object(r.b)("p",null,"As a convenience, especially while developing, it is nice to be able to not have to worry about listing the fields you want rendered. For that reason Praxis Media Types have the concept of a ",Object(r.b)("inlineCode",{parentName:"p"},"default_fieldset"),", which defines what attributes to return if no specific fields have been asked for. By default, Praxis will calculate this default fieldset as the set of terminal fields (i.e., simple fields that aren't other related MediaTypes). In the case for our Blog above, the ",Object(r.b)("inlineCode",{parentName:"p"},"default_fieldset")," will only contain the ",Object(r.b)("inlineCode",{parentName:"p"},"id"),", ",Object(r.b)("inlineCode",{parentName:"p"},"href"),", ",Object(r.b)("inlineCode",{parentName:"p"},"subject")," and ",Object(r.b)("inlineCode",{parentName:"p"},"locale"),", but it will leave out the ",Object(r.b)("inlineCode",{parentName:"p"},"owner")," as it would recurse into the fields of a ",Object(r.b)("inlineCode",{parentName:"p"},"Person")," media type."),Object(r.b)("p",null,"You can easily override the Praxis-picked set of fields and define them yourself using the ",Object(r.b)("inlineCode",{parentName:"p"},"default_fieldset")," DSL. For example, the following restrict the default fields to only have ",Object(r.b)("inlineCode",{parentName:"p"},"id"),", ",Object(r.b)("inlineCode",{parentName:"p"},"href")," and ",Object(r.b)("inlineCode",{parentName:"p"},"subject"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Blog < Praxis::MediaType\n  description 'A Blog API resource represents...'\n  identifier 'application/vnd.acme.blog'\n\n  attributes do\n    attribute :id, Integer\n    attribute :href, String\n    attribute :owner, Person\n    attribute :subject, String\n    attribute :locale do\n      attribute :language, String\n      attribute :country, String\n    end\n  end\n\n  default_fieldset do\n    attribute :id\n    attribute :href\n    attribute :subject\n  end\nend\n")),Object(r.b)("h2",{id:"collections"},"Collections"),Object(r.b)("p",null,"Often times, we need to expose arrays of media types. In fact, this is very common for a given media type to embed collections of other related media types or even the case of returning a full top-level collection of mediatypes in an ",Object(r.b)("inlineCode",{parentName:"p"},"index")," API response."),Object(r.b)("p",null,"To help in defining those, Praxis provides a ",Object(r.b)("inlineCode",{parentName:"p"},"Praxis::Collection")," class."),Object(r.b)("h3",{id:"praxiscollection"},"Praxis::Collection"),Object(r.b)("p",null,"To define a related collection of mediatype objects, you can use ",Object(r.b)("inlineCode",{parentName:"p"},"Praxis::Collection.of(media_type)"),"\nFor example, here is how you would define a collection of related Post media types for your Blog:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Blog < Praxis::MediaType\n  attributes do\n    attribute :id, Integer\n    attribute :posts, Praxis::Collection.of(Post)\n  end\nend\n")),Object(r.b)("p",null,"In its underbelly, this ",Object(r.b)("inlineCode",{parentName:"p"},"Praxis::Collection.of")," type is backed by the ",Object(r.b)("inlineCode",{parentName:"p"},"Collection")," class of Attributor, which also includes the ",Object(r.b)("inlineCode",{parentName:"p"},"Praxis::MediaTypeCommon")," module in it. For the folk interested in greedy details, it would be interested to know that this resulting Attributor type is gonna be stored in a ",Object(r.b)("inlineCode",{parentName:"p"},"Collection")," constant under the ",Object(r.b)("inlineCode",{parentName:"p"},"Post")," mediatype. In other words, one can think of ",Object(r.b)("inlineCode",{parentName:"p"},"Praxis::Collection.of(Post)")," to be equivalent to accessing ",Object(r.b)("inlineCode",{parentName:"p"},"Post::Collection"),", except that it will create one if it does not exist already. "),Object(r.b)("p",null,"As stated above, the created inner ",Object(r.b)("inlineCode",{parentName:"p"},"Collection")," class will simply be an ",Object(r.b)("inlineCode",{parentName:"p"},"Attributor::Collection"),' that wraps members of a given MediaType, and that has an identifier that matches the member\'s identifier, with an added "collection=true" suffix. So in the above case, the ',Object(r.b)("inlineCode",{parentName:"p"},"Post::Collection"),' will have an identifier of "application/vnd.acme.post;collection=true".'),Object(r.b)("p",null,"This inner ",Object(r.b)("inlineCode",{parentName:"p"},"Collection")," should be sufficient in most cases. However, you can explicitly define your own and Praxis will use that instead. Here's an example of how to do that if you wanted ",Object(r.b)("inlineCode",{parentName:"p"},"Post::Collection"),' to have an identifier of "application/vnd.acme.posts" instead:'),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Post < Praxis::MediaType\n  identifier 'application/vnd.acme.post'\n  # ...\n\n  class Collection < Attributor::Collection\n    member_type Post\n    identifier 'application/vnd.acme.posts'\n  end\nend\n")),Object(r.b)("p",null,"Note: When defined without using the ",Object(r.b)("inlineCode",{parentName:"p"},".of")," helper, you use the ",Object(r.b)("inlineCode",{parentName:"p"},"member_type")," method to specify what type of media type class this collection is wrapping. If you want a non-anonymous class that is a collection and also has other attributes (such as description), you have two ways to define it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"# Option 1: implicit collection type; reopen class to add more information\nCommentThread = Praxis::Collection.of(Comment)\nclass CommentThread\n  description 'A sequence of comments on a blog post.'\nend\n\n# Option 2: explicit collection type with member_type specified inline\nclass CommentThread < Praxis::Collection\n  member_type Comment\n  description 'A sequence of comments on a blog post.'\nend\n")),Object(r.b)("h3",{id:"attributorcollection"},"Attributor::Collection"),Object(r.b)("p",null,"An Attributor::Collection (as opposed to ",Object(r.b)("inlineCode",{parentName:"p"},"Praxis::Collection"),") is the way to embed a collection of lower-level types that aren't media types. In fact they use the same ",Object(r.b)("inlineCode",{parentName:"p"},".of(type)")," method to create the types."),Object(r.b)("p",null,"For example, you may want a collection of tag strings to be an attribute of your blog media type:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ruby"}),"class Blog < Praxis::MediaType\n  attributes do\n    attribute :id, Integer\n    attribute :tags, Attributor::Collection.of(String)\n  end\nend\n")),Object(r.b)("h2",{id:"rendering-mediatypes"},"Rendering mediatypes"),Object(r.b)("p",null,"Maybe some of this data is best to be brought up in implementation rendering?...."),Object(r.b)("p",null,"????"),Object(r.b)("p",null,"Once a media type is defined within your application, you can use it to wrap a\ncompatible data object holding resource data, and render it using any of the\navailable views. A compatible object must respond to the method names matching\nthe media type attribute names, and return sub-objects that are compatible with\nthe types defined in the media type. Praxis renders media types into ",Object(r.b)("inlineCode",{parentName:"p"},"Hash"),"\nstructures to achieve format-independence.  These rendered hash structures can\nbe formatted in your application using the desired wire encoding (JSON, XML, or\nany other type you might need)."),Object(r.b)("p",null,"Here are two examples of how to render a blog_object using the ",Object(r.b)("inlineCode",{parentName:"p"},"Blog")," media\ntype: one using its ",Object(r.b)("inlineCode",{parentName:"p"},"default")," view and another using its ",Object(r.b)("inlineCode",{parentName:"p"},"link")," view:"),Object(r.b)("p",null,"{% highlight ruby %}\nBlog.render(blog_object, view: :default)\n=> {\n'id' : 123,\n'owner' : { ...an owner hash rendered with its :compact view...},\n'subject' : 'First post',\n'locale' : { 'language': 'en', 'country': 'us' }\n}"),Object(r.b)("p",null,"Blog.render(blog_object, view: :link)\n=> { 'href' : '/blogs/123' }\n{% endhighlight %}"),Object(r.b)("p",null,"In this example, your ",Object(r.b)("inlineCode",{parentName:"p"},"blog_object")," must return:"),Object(r.b)("p",null,"{% highlight bash %}\n+---------+---------------------------------------------+\n| Method  | Return value                                |\n|---------+---------------------------------------------|\n| id      | integer                                     |\n| owner   | object compatible with a Person media type  |\n| subject | String                                      |\n| locale  | object compatible with the locale structure |\n| href    | String                                      |\n+---------+---------------------------------------------+\n{% endhighlight %}"),Object(r.b)("p",null,"Praxis provides a lot of help in managing resource objects and linking them to\ndata sources (including databases) by integrating with the\n",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://rubygems.org/gems/praxis-mapper"}),"Praxis::Mapper")," gem."),Object(r.b)("p",null,"Also, Praxis allows you to generate compatible objects using the ",Object(r.b)("inlineCode",{parentName:"p"},".example"),"\nfeature of MediaType classes. Using this ",Object(r.b)("inlineCode",{parentName:"p"},".example")," feature you can create\nrandom instances of compatible objects without any extra effort, which is great\nto simulate returning data objects when testing controller responses without\nrequiring any data source access. There is also some help available for\ncreating realistic examples for your test cases. See more ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"#examples"}),"examples"),"\nat the end of this document."),Object(r.b)("h2",{id:"examples"},"Examples"),Object(r.b)("p",null,"??? TODO????"),Object(r.b)("p",null,"Praxis provides tools to automatically generate example object values that will\nrespond to each and every attribute name of a media type and will return an\nobject that responds to the correct methods of their defined type, including\nwhen the attribute type is another media type."),Object(r.b)("p",null,"The values of the generated example attributes will also conform to\nspecifications like default values, regexp, etc."),Object(r.b)("p",null,"Please see ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://rubygems.org/gems/praxis-mapper"}),"Praxis::Mapper")," and\n",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://rubygems.org/gems/attributor"}),"Attributor")," for more on generating\nexample objects."))}p.isMDXComponent=!0},133:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var i=n(0),a=n.n(i);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,m=d["".concat(o,".").concat(u)]||d[u]||b[u]||r;return n?a.a.createElement(m,s(s({ref:t},c),{},{components:n})):a.a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);